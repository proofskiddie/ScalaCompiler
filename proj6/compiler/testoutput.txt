"C:\Users\skidd9\.sbt\preloaded\org.scala-sbt\sbt\"1.0.0"\jars\sbt.jar"
[info] Loading global plugins from C:\Users\skidd9\.sbt\0.13\plugins
[info] Loading project definition from C:\Users\skidd9\Desktop\Compilers\proj6\compiler\project
[info] Set current project to CMScala-compiler (in build file:/C:/Users/skidd9/Desktop/Compilers/proj6/compiler/)
[info] Test run started
[info] Test miniscala.test.CPSOptimizer_Greybox.testNeutralElementsMulOne1 started
[info] Test miniscala.test.CPSOptimizer_Greybox.testNeutralElementsMulOne2 started
[info] Test miniscala.test.CPSOptimizer_Greybox.testEtaReduction started
[error] Test miniscala.test.CPSOptimizer_Greybox.testEtaReduction failed: assertion failed: Checks failed for: 
[error] 
[error]       def f(x: Int) = x; def g(y: Int) = f(y); def h(z: Int) = g(z);
[error]       g(1) + g(2) + g(3) + h(1) + h(2) + h(3) + f(1) + f(2) + f(3)
[error]     
[error] Statistics:
[error] Instruction Stats
[error] =================
[error]       18  AppF
[error]        9  AppC
[error]        9  LetC
[error]        5  LetL
[error]        1  LetP
[error]        1  LetF
[error]        1  Halt
[error] 
[error] Value Primitives Stats
[error] ======================
[error]        1  CPSArithShiftR$
[error] 
[error] Functions defined: 3
[error] Continuations defined: 9
[info] Test miniscala.test.CPSOptimizer_Greybox.testFunInlining started
[info] Test miniscala.test.CPSOptimizer_Greybox.testFunInlingAndDCE started
[info] Test miniscala.test.CPSOptimizer_Greybox.testNeutralElementsDivOne started
[info] Test miniscala.test.CPSOptimizer_Greybox.testInliningConstantFoldingDCE started
[error] Test miniscala.test.CPSOptimizer_Greybox.testInliningConstantFoldingDCE failed: key not found: fun$1_1
[error]     at scala.collection.MapLike$class.default(MapLike.scala:228)
[error]     at scala.collection.AbstractMap.default(Map.scala:59)
[error]     at scala.collection.MapLike$class.apply(MapLike.scala:141)
[error]     at scala.collection.AbstractMap.apply(Map.scala:59)
[error]     at miniscala.test.infrastructure.CPSTest$CPSVariableRenamePhase$.miniscala$test$infrastructure$CPSTest$CPSVariableRenamePhase$$updateName(CPSTest.scala:31)
[error]     at miniscala.test.infrastructure.CPSTest$CPSVariableRenamePhase$.updateTree(CPSTest.scala:48)
[error]     at miniscala.test.infrastructure.CPSTest$CPSVariableRenamePhase$.updateTree(CPSTest.scala:44)
[error]     at miniscala.test.infrastructure.CPSTest$CPSVariableRenamePhase$.updateTree(CPSTest.scala:42)
[error]     at miniscala.test.infrastructure.CPSTest$CPSVariableRenamePhase$.updateTree(CPSTest.scala:44)
[error]     at miniscala.test.infrastructure.CPSTest$CPSVariableRenamePhase$.updateTree(CPSTest.scala:42)
[error]     at miniscala.test.infrastructure.CPSTest$CPSVariableRenamePhase$.miniscala$test$infrastructure$CPSTest$CPSVariableRenamePhase$$updateFunction(CPSTest.scala:74)
[error]     at miniscala.test.infrastructure.CPSTest$CPSVariableRenamePhase$$anonfun$updateTree$6.apply(CPSTest.scala:62)
[error]     at miniscala.test.infrastructure.CPSTest$CPSVariableRenamePhase$$anonfun$updateTree$6.apply(CPSTest.scala:62)
[error]     at scala.Function2$$anonfun$tupled$1.apply(Function2.scala:48)
[error]     at scala.Function2$$anonfun$tupled$1.apply(Function2.scala:47)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.foreach(List.scala:381)
[error]     at scala.collection.TraversableLike$class.map(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.map(List.scala:285)
[error]     at miniscala.test.infrastructure.CPSTest$CPSVariableRenamePhase$.updateTree(CPSTest.scala:62)
[error]     at miniscala.test.infrastructure.CPSTest$CPSVariableRenamePhase$.apply(CPSTest.scala:36)
[error]     at miniscala.test.infrastructure.CPSTest$CPSVariableRenamePhase$.apply(CPSTest.scala:17)
[error]     at scala.Function1$$anonfun$andThen$1.apply(Function1.scala:52)
[error]     at scala.Function1$$anonfun$andThen$1.apply(Function1.scala:52)
[error]     at miniscala.test.infrastructure.CompilerTest$class.miniscala$test$infrastructure$CompilerTest$$compileInner(CompilerTest.scala:37)
[error]     at miniscala.test.infrastructure.CompilerTest$$anonfun$compileUsingPipeline$1.apply(CompilerTest.scala:41)
[error]     at miniscala.test.infrastructure.SandboxedTest$$anon$1.run(SandboxedTest.scala:24)
[error]     at java.security.AccessController.doPrivileged(Native Method)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTest(SandboxedTest.scala:34)
[error]     at miniscala.test.infrastructure.CompilerTest$class.compileUsingPipeline(CompilerTest.scala:41)
[error]     at miniscala.test.infrastructure.CPSTest.compileUsingPipeline(CPSTest.scala:11)
[error]     at miniscala.test.infrastructure.CPSOptTest.testCPSOptTreeEquality(CPSOptTest.scala:43)
[error]     at miniscala.test.CPSOptimizer_Greybox.testInliningConstantFoldingDCE(CPSOptimizer_Greybox.scala:156)
[error]     ...
[info] Test miniscala.test.CPSOptimizer_Greybox.testNeutralElementsMulZero2 started
[info] Test miniscala.test.CPSOptimizer_Greybox.testNeutralElementsMulZero1 started
[info] Test miniscala.test.CPSOptimizer_Greybox.testConstantFoldingDiv started
[info] Test miniscala.test.CPSOptimizer_Greybox.testConstantFoldingTimes started
[info] Test miniscala.test.CPSOptimizer_Greybox.testConstantFoldingMod started
[info] Test miniscala.test.CPSOptimizer_Greybox.testDCELetPrimitive started
[info] Test miniscala.test.CPSOptimizer_Greybox.testConstantFoldingIntP started
[info] Test miniscala.test.CPSOptimizer_Greybox.testConstantFoldingIntChar started
[info] Test miniscala.test.CPSOptimizer_Greybox.testConstantFoldingMinus started
[info] Test miniscala.test.CPSOptimizer_Greybox.testConstantFoldingCharInt started
[info] Test miniscala.test.CPSOptimizer_Greybox.testDCELetLiteral started
[info] Test miniscala.test.CPSOptimizer_Greybox.testFunInliningRecursiveTrick started
[info] Test miniscala.test.CPSOptimizer_Greybox.testDCEFunsRecursive1 started
[info] Test miniscala.test.CPSOptimizer_Greybox.testDCEFunsSimple started
[info] Test miniscala.test.CPSOptimizer_Greybox.testConstantFoldingIntPNot started
[info] Test miniscala.test.CPSOptimizer_Greybox.testConstantFoldingPlus started
[info] Test miniscala.test.CPSOptimizer_Greybox.testConstantFoldingTypePrims started
[info] Test miniscala.test.CPSOptimizer_Greybox.testDCEFunsRecursive2 started
[info] Test miniscala.test.CPSOptimizer_Greybox.testFunInliningCrasher started
[info] Test miniscala.test.CPSOptimizer_Greybox.testConstantCapturingInFunction2 started
[error] Test miniscala.test.CPSOptimizer_Greybox.testConstantCapturingInFunction2 failed: assertion failed: Checks failed for: 
[error] val one = 1; def f(x: Int) = x + one; f(1) + f(2) + f(3) + one
[error] Statistics:
[error] Instruction Stats
[error] =================
[error]        7  LetL
[error]        6  LetP
[error]        3  AppC
[error]        3  AppF
[error]        3  LetC
[error]        1  LetF
[error]        1  Halt
[error] 
[error] Value Primitives Stats
[error] ======================
[error]        3  CPSSub$
[error]        3  CPSAdd$
[error] 
[error] Functions defined: 1
[error] Continuations defined: 3
[info] Test miniscala.test.CPSOptimizer_Greybox.testConstantFoldingBooleanOr started
[info] Test miniscala.test.CPSOptimizer_Greybox.testConstantFoldDCEContinuations started
[error] Test miniscala.test.CPSOptimizer_Greybox.testConstantFoldDCEContinuations failed: assertion failed: Checks failed for: 
[error] if (true) 1 else 2
[error] Statistics:
[error] Instruction Stats
[error] =================
[error]        3  LetC
[error]        2  LetL
[error]        1  LetP
[error]        1  LetF
[error]        1  Halt
[error] 
[error] Value Primitives Stats
[error] ======================
[error]        1  CPSArithShiftR$
[error] 
[error] Functions defined: 0
[error] Continuations defined: 0
[info] Test miniscala.test.CPSOptimizer_Greybox.testNeutralElementsAddZero1 started
[info] Test miniscala.test.CPSOptimizer_Greybox.testNeutralElementsAddZero2 started
[info] Test miniscala.test.CPSOptimizer_Greybox.testConstantFoldingBooleanAnd started
[info] Test miniscala.test.CPSOptimizer_Greybox.testNeutralElementsSubZero started
[info] Test miniscala.test.CPSOptimizer_Greybox.testNeutralElementsSubItself started
[info] Test miniscala.test.CPSOptimizer_Greybox.testConstantPropagationSimple started
[info] Test miniscala.test.CPSOptimizer_Greybox.testConstantCapturingInFunction1 started
[error] Test miniscala.test.CPSOptimizer_Greybox.testConstantCapturingInFunction1 failed: assertion failed: Checks failed for: 
[error] val a = 1; val b = 2; val c = 3; def f(x: Int) = x + a + b + c; putchar(f(getchar()) + f(1) + f(1))
[error] Statistics:
[error] Instruction Stats
[error] =================
[error]       27  LetP
[error]        8  LetL
[error]        3  AppC
[error]        3  AppF
[error]        3  LetC
[error]        1  LetF
[error]        1  Halt
[error] 
[error] Value Primitives Stats
[error] ======================
[error]       11  CPSSub$
[error]       11  CPSAdd$
[error]        1  CPSByteWrite$
[error]        1  CPSArithShiftL$
[error]        1  CPSOr$
[error]        1  CPSArithShiftR$
[error]        1  CPSByteRead$
[error] 
[error] Functions defined: 1
[error] Continuations defined: 3
[info] Test miniscala.test.CPSOptimizer_Greybox.testCommonSubexpressionEliminationComplexBlockTag started
[error] Test miniscala.test.CPSOptimizer_Greybox.testCommonSubexpressionEliminationComplexBlockTag failed: assertion failed: Checks failed for: 
[error] val a = new Array[Int](300); val p = putchar(getchar()); putchar((if (a.isArray) 90 else 80) + (if (a.isList) 6 else 7))
[error] Statistics:
[error] Instruction Stats
[error] =================
[error]       18  LetC
[error]       18  LetP
[error]       16  LetL
[error]        7  If
[error]        4  AppC
[error]        1  LetF
[error]        1  Halt
[error] 
[error] Value Primitives Stats
[error] ======================
[error]        3  CPSArithShiftL$
[error]        3  CPSOr$
[error]        2  CPSByteWrite$
[error]        2  CPSArithShiftR$
[error]        2  CPSBlockTag$
[error]        2  CPSAnd$
[error]        1  CPSBlockAlloc
[error]        1  CPSSub$
[error]        1  CPSByteRead$
[error]        1  CPSAdd$
[error] 
[error] Logic Primitives Stats
[error] ======================
[error]        5  CPSEq$
[error]        2  CPSNe$
[error] 
[error] Functions defined: 0
[error] Continuations defined: 18
[info] Test miniscala.test.CPSOptimizer_Greybox.testFunInliningInsideFunctionBodyDifferentLetRecs started
[info] Test miniscala.test.CPSOptimizer_Greybox.testDCEFunsRecursive3WithEtaReduction started
[error] Test miniscala.test.CPSOptimizer_Greybox.testDCEFunsRecursive3WithEtaReduction failed: key not found: g
[error]     at scala.collection.MapLike$class.default(MapLike.scala:228)
[error]     at scala.collection.AbstractMap.default(Map.scala:59)
[error]     at scala.collection.MapLike$class.apply(MapLike.scala:141)
[error]     at scala.collection.AbstractMap.apply(Map.scala:59)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.mutable.ResizableArray$class.foreach(ResizableArray.scala:59)
[error]     at scala.collection.mutable.ArrayBuffer.foreach(ArrayBuffer.scala:48)
[error]     at scala.collection.TraversableLike$class.map(TraversableLike.scala:245)
[error]     at scala.collection.AbstractTraversable.map(Traversable.scala:104)
[error]     at miniscala.CPSInterpreter.eval(CPSInterpreter.scala:66)
[error]     at miniscala.CPSInterpreter.apply(CPSInterpreter.scala:18)
[error]     at miniscala.CPSInterpreterLow.apply(CPSInterpreter.scala:176)
[error]     at scala.Function1$$anonfun$andThen$1.apply(Function1.scala:52)
[error]     at miniscala.test.infrastructure.CompilerTest$class.miniscala$test$infrastructure$CompilerTest$$compileInner(CompilerTest.scala:37)
[error]     at miniscala.test.infrastructure.CompilerTest$$anonfun$compileUsingPipelineAndRedirect$1.apply(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.SandboxedTest$$anon$1.run(SandboxedTest.scala:24)
[error]     at java.security.AccessController.doPrivileged(Native Method)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTest(SandboxedTest.scala:34)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTestWithRedirectedIO(SandboxedTest.scala:45)
[error]     at miniscala.test.infrastructure.CompilerTest$class.compileUsingPipelineAndRedirect(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.CPSTest.compileUsingPipelineAndRedirect(CPSTest.scala:11)
[error]     at miniscala.test.infrastructure.CPSOptTest.testCPSOptStats(CPSOptTest.scala:60)
[error]     at miniscala.test.infrastructure.CPSOptTest.testCPSOptEarly(CPSOptTest.scala:67)
[error]     at miniscala.test.CPSOptimizer_Greybox.testDCEFunsRecursive3WithEtaReduction(CPSOptimizer_Greybox.scala:33)
[error]     ...
[info] Test miniscala.test.CPSOptimizer_Greybox.testFunInliningInsideFunctionBodySameLetRec started
[error] Test miniscala.test.CPSOptimizer_Greybox.testFunInliningInsideFunctionBodySameLetRec failed: key not found: f
[error]     at scala.collection.MapLike$class.default(MapLike.scala:228)
[error]     at scala.collection.AbstractMap.default(Map.scala:59)
[error]     at scala.collection.MapLike$class.apply(MapLike.scala:141)
[error]     at scala.collection.AbstractMap.apply(Map.scala:59)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.foreach(List.scala:381)
[error]     at scala.collection.TraversableLike$class.map(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.map(List.scala:285)
[error]     at miniscala.CPSInterpreter.eval(CPSInterpreter.scala:40)
[error]     at miniscala.CPSInterpreter.apply(CPSInterpreter.scala:18)
[error]     at miniscala.CPSInterpreterLow.apply(CPSInterpreter.scala:176)
[error]     at scala.Function1$$anonfun$andThen$1.apply(Function1.scala:52)
[error]     at miniscala.test.infrastructure.CompilerTest$class.miniscala$test$infrastructure$CompilerTest$$compileInner(CompilerTest.scala:37)
[error]     at miniscala.test.infrastructure.CompilerTest$$anonfun$compileUsingPipelineAndRedirect$1.apply(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.SandboxedTest$$anon$1.run(SandboxedTest.scala:24)
[error]     at java.security.AccessController.doPrivileged(Native Method)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTest(SandboxedTest.scala:34)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTestWithRedirectedIO(SandboxedTest.scala:45)
[error]     at miniscala.test.infrastructure.CompilerTest$class.compileUsingPipelineAndRedirect(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.CPSTest.compileUsingPipelineAndRedirect(CPSTest.scala:11)
[error]     at miniscala.test.infrastructure.CPSOptTest.testCPSOptStats(CPSOptTest.scala:60)
[error]     at miniscala.test.infrastructure.CPSOptTest.testCPSOptEarly(CPSOptTest.scala:67)
[error]     at miniscala.test.CPSOptimizer_Greybox.testFunInliningInsideFunctionBodySameLetRec(CPSOptimizer_Greybox.scala:46)
[error]     ...
[info] Test miniscala.test.CPSOptimizer_Greybox.testEtaReductionInfintelyRecursiveFunction started
[error] Test miniscala.test.CPSOptimizer_Greybox.testEtaReductionInfintelyRecursiveFunction failed: assertion failed: Checks failed for: 
[error] def f(x: Int): Int = g(x); def g(x: Int): Int = f(x); if (getchar() == -1) g(3) else 0
[error] Statistics:
[error] Instruction Stats
[error] =================
[error]        5  LetL
[error]        4  LetP
[error]        3  LetC
[error]        1  AppC
[error]        1  If
[error]        1  LetF
[error]        1  Halt
[error] 
[error] Value Primitives Stats
[error] ======================
[error]        1  CPSArithShiftL$
[error]        1  CPSOr$
[error]        1  CPSArithShiftR$
[error]        1  CPSByteRead$
[error] 
[error] Logic Primitives Stats
[error] ======================
[error]        1  CPSEq$
[error] 
[error] Functions defined: 0
[error] Continuations defined: 3
[info] Test miniscala.test.CPSOptimizer_Greybox.testCommonSubexpressionEliminationSimpleBlockTag started
[error] Test miniscala.test.CPSOptimizer_Greybox.testCommonSubexpressionEliminationSimpleBlockTag failed: assertion failed: Checks failed for: 
[error] val a = new Array[Int](1); putchar(if (a.isList || a.isArray) 96 else 87)
[error] Statistics:
[error] Instruction Stats
[error] =================
[error]       16  LetC
[error]       12  LetL
[error]       11  LetP
[error]        7  If
[error]        3  AppC
[error]        1  LetF
[error]        1  Halt
[error] 
[error] Value Primitives Stats
[error] ======================
[error]        2  CPSArithShiftL$
[error]        2  CPSOr$
[error]        2  CPSBlockTag$
[error]        2  CPSAnd$
[error]        1  CPSBlockAlloc
[error]        1  CPSByteWrite$
[error]        1  CPSArithShiftR$
[error] 
[error] Logic Primitives Stats
[error] ======================
[error]        5  CPSEq$
[error]        2  CPSNe$
[error] 
[error] Functions defined: 0
[error] Continuations defined: 16
[info] Test run finished: 10 failed, 0 ignored, 42 total, 4.157s
[info] Test run started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testLibFunctions3 started
def printChar(c: Char) = putchar(c.toInt);

def charRead() = getchar().toChar;

def println() = printChar('\n');

val int0 = '0'.toInt;
val int9 = '9'.toInt;
def isCharDigit(c: Char) = {
  val intC = c.toInt;
  int0 <= intC && intC <= int9
};

def charDigitToInt(c: Char) = c.toInt - int0;

def intCharDigit(i: Int) = (i + int0).toChar;

def functionCompose[T,U,V](f: U => V, g: T => U) = (x: T) => f(g(x));

// Integers

def isEven(i: Int) = 0 == (1 & i);

def isOdd(i: Int) = !isEven(i);

def intAbs(i: Int) = if (i < 0) -i else i;

def intSignum(i: Int) = if (i < 0) -1 else { if (i == 0) 0 else 1 };

def intGcd(x: Int, y: Int) = {
    def auxGcd(x: Int, y: Int): Int = {
      if (0 == y)
        x
      else
        auxGcd(y, x % y)
    };
    auxGcd(intAbs(x), intAbs(y))
};

def intPow(x: Int, y: Int): Int = {
  if (y == 0)
    1
  else {
    if (isEven(y)) {
      val t = intPow(x, y/2);
      t * t
    } else {
      x * intPow(x, y - 1)
    }
  }
};

def intRead() = {
  def aux(accf: (Int, Int) => Int, acc: Int): Int = {
    val c = charRead();
    if (isCharDigit(c)) {
      aux(accf, accf(10 * acc, charDigitToInt(c)))
    } else {
      acc
    }
  };
  val c = charRead();
  if (c == '-') {
    aux((x: Int, y: Int) => x - y, 0)
  } else if (isCharDigit(c)) {
    aux((x: Int, y: Int) => x + y, charDigitToInt(c))
  } else {
    0
  }
};

def printInt(i: Int) = {
  if (i < 0) {
    printChar('-')
  };
  def aux(i: Int): Unit = {
    if (i <= -10)
      aux((i + 9) / 10);
    printChar(intCharDigit(-i % 10))
  };
  aux(if (i < 0) i else -i)
};

def pairDeriveEq[T,U](eq1: (T, T) => Boolean, eq2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => eq1(p1._1, p2._1) && eq2(p1._2, p2._2);

def pairDeriveLt[T,U](lt1: (T, T) => Boolean, lt2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => lt1(p1._1, p2._1) || (!lt1(p1._1, p2._1) && lt2(p1._2, p2._2));

def listMake1[T](e1: T) = e1::Nil;
def listMake2[T](e1: T, e2: T) = e1::listMake1[T](e2);
def listMake3[T](e1: T, e2: T, e3: T) = e1::listMake2[T](e2, e3);
def listMake4[T](e1: T, e2: T, e3: T, e4: T) = e1::listMake3[T](e2, e3, e4);
def listMake5[T](e1: T, e2: T, e3: T, e4: T, e5: T) = e1::listMake4[T](e2, e3, e4, e5);
def listMake6[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T) = e1::listMake5[T](e2, e3, e4, e5, e6);
def listMake7[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T) = e1::listMake6[T](e2, e3, e4, e5, e6, e7);
def listMake8[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T, e8: T) = e1::listMake7[T](e2, e3, e4, e5, e6, e7, e8);

def listTabulate[T](n: Int, f: Int => T) = {
  def aux(i: Int, l: List[T]): List[T] = {
    if (i == 0)
      l
    else
      aux(i - 1, f(i - 1)::l)
  };
  aux(n, Nil)
};

def listLength[T](l: List[T]): Int =
  if (l.isEmpty)
    0
  else
    1 + listLength[T](l.tail);

def listForeach[T](f: T => Unit, l: List[T]): Unit =
  if (!l.isEmpty) {
    f(l.head);
    listForeach[T](f, l.tail)
  };

def listMap[T,U](f: T => U, l: List[T]): List[U] =
  if (l.isEmpty)
    Nil
  else
    f(l.head)::listMap[T,U](f, l.tail);

def listFoldLeft[T,U](f: (T, U) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    listFoldLeft[T,U](f, f(z, l.head), l.tail);

def listFoldRight[T,U](f: (U, T) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    f(l.head, listFoldRight[T,U](f, z, l.tail));

def listEvery[T](p: T => Boolean, l: List[T]): Boolean =
  l.isEmpty || p(l.head) && listEvery[T](p, l.tail);

def listAny[T](p: T => Boolean, l: List[T]): Boolean =
  !l.isEmpty && (p(l.head) || listAny[T](p, l.tail));

def listFilter[T](p: T => Boolean, l: List[T]): List[T] =
  listFoldRight[List[T],T]((e: T, r: List[T]) =>  if (p(e)) e::r else r, Nil, l);

def listPartition[T](p: T => Boolean, l: List[T]) =
  listFoldRight[(List[T], List[T]),T](
    (e: T,  yn: (List[T], List[T])) =>
      if (p(e))
        (e::yn._1, yn._2)
      else
        (yn._1, e::yn._2),
      (Nil, Nil),
      l);

def listTake[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    Nil
  else
    l.head :: listTake[T](l.tail, n - 1);

def listDrop[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    l
  else
    listDrop[T](l.tail, n - 1);

def listNth[T](l: List[T], n: Int): T =
  listDrop[T](l, n).head;

def listReverse[T](l: List[T]): List[T] =
  listFoldLeft[List[T],T]((t: List[T], h: T) => h::t, Nil, l);

def listAppend[T](l1: List[T], l2: List[T]) =
  if (l1.isEmpty) l2
  else if (l2.isEmpty) l1
  else l1.head :: listAppend[T](l1.tail, l2);

def listZip[T,U](l1: List[T], l2: List[U]): List[(T, U)] =
  if (l1.isEmpty  || l2.isEmpty)
    Nil
  else
    (l1.head, l2.head) :: listZip[T,U](l1.tail, l2.tail);

def printString(s: String) = {
  var idx = 0;
  while (idx < s.length) {
    printChar(s(idx));
    idx = idx + 1
  };
  ()
};

def stringConcat(s1: String, s2: String) = {
  val s3 = new Array[Char](s1.length + s2.length);
  var idx = 0;
  while (idx < s1.length) {
    s3(idx) = s1(idx);
    idx = idx + 1
  };
  idx = 0;
  while (idx < s2.length) {
    s3(s1.length + idx) = s2(idx);
    idx = idx + 1
  };
  s3
};

// A PCG random number generator. (Specifically, this is the variant
// called XSH RR in the paper, with a 16-bit state and 8-bit output).
// See http://www.pcg-random.org/

def makeRNG(seed: Int) = {
  val rng = new Array[Int](1);
  rng(0) = seed & 0xFFFF;
  rng
};

def rngGetState(rng: Array[Int]) = rng(0);

def rngSetState(rng: Array[Int], state: Int) = rng(0) = state & 0xFFFF;

def rngRotateRight8(x: Int, y: Int) =
  ((x >> y) | (x << (8 - y))) & 0xFF;

def rngStep(rng: Array[Int]) =
  rngSetState(rng, rngGetState(rng) * 12829 + 47989);

def rngOutput(rng: Array[Int]) = {
  val state = rngGetState(rng);
  rngRotateRight8(0xFF & ((state ^ (state >> 5)) >> 5), state >> 13)
};

// Return the next 8-bit unsigned integer (0 to 255, included)
def rngNextInt8(rng: Array[Int]) = {
  val i = rngOutput(rng);
  rngStep(rng);
  i
};

// FIXME: this is hackish, find a better way to do it (probably using
// multiple streams, see sample/pcg32x2-demo.c in the PCG source).
def rngNextInt(rng: Array[Int]) = {
  val b0 = rngNextInt8(rng);
  val b1 = rngNextInt8(rng);
  val b2 = rngNextInt8(rng);
  val b3 = rngNextInt8(rng);
  (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
};

def arrayTabulate[T](n: Int, f: Int => T) = {
  val v = new Array[T](n);
  var i = 0;
  while (i < n) {
    v(i) = f(i);
    i = i + 1
  };
  v
};

def arraySwap[T](v: Array[T], i1: Int, i2: Int) = {
  val t = v(i1);
  v(i1) = v(i2);
  v(i2) = t
};

def arrayShuffle[T](v: Array[T], seed: Int) = {
  val rng = makeRNG(seed);
  val l = v.length;
  var i = 0;
  while (i < l) {
    val j = i + rngNextInt(rng) % (l - i);
    arraySwap[T](v, i, j);
    i = i + 1
  };
  ()
};

def auxArrayPartition[T](v: Array[T], p: T => Boolean, l: Int, h: Int) = {
  def loop(l: Int, h: Int): Int = {
    if (l >= h)
      l
    else if (p(v(l)))
      loop(l + 1, h)
    else if (!p(v(h-1)))
      loop(l, h - 1)
    else {
      arraySwap[T](v, l, h - 1);
      loop(l + 1, h + 1)
    }
  };
  loop(l, h)
};

// Reorganize the elements of the vector so that all those not
// satisfying the predicate [p] are before those that satisfy it.
// Return the index of the first element not satisfying [p], or the
// length of the vector if all elements satisfy [p].
def arrayPartition[T](v: Array[T], p: T => Boolean) =
  auxArrayPartition[T](v, p, 0, v.length);

def arrayFoldLeft[T,U](f: (T,U) => T, z: T, v: Array[U]) = {
  var i = 0;
  val l = v.length;
  var zz = z;
  while (i < l) {
    zz = f(zz, v(i));
    i = i + 1
  };
  zz
};

def arrayForeach[T](f: T => Unit, v: Array[T]) = {
  var i = 0;
  val l = v.length;
  while (i < l) {
    f(v(i));
    i = i + 1
  };
  ()
};

def arraySort[T](v: Array[T], el: (T, T) => Boolean) = {
  def qsort(l: Int, h: Int) = {
    if (h - l > 0) {
       val p = v(h);
       val pred = (x: T) => el(x, p);
       val m = auxArrayPartition[T](v, pred, l, h);
       arraySwap[T](v, m, h);
       qsort(l, m - 1);
       qsort(m + 1, h)
    }
  };
  qsort(0, v.length - 1)
};

def arrayBinarySearch[T](v: Array[T], e: T, el: (T, T) => Boolean) = {
  def loop(l: Int, h: Int): Int = {
    if (l > h)
      -1 -[error] Test miniscala.test.CPSOptimizer_Blackbox.testLibFunctions3 failed: key not found: fun$1_2
 l
    else {
      val m = l + (h - l) / 2;
      val me = v(m);
      if (el(e, me))
        loop(l, m - 1)
      else if (el(me, e))
        loop(m + 1, h)
      else
        m
    }
  };
  loop(0, v.length - 1)
};

def arrayToList[T](v: Array[T]) = {
  def loop(i: Int): List[T] = {
    if (i == -1)
      Nil
    else
      v(i)::loop(i - 1)
  };
  loop(v.length - 1)
};

def listToArray[T](l: List[T]) = {
  val n = listLength[T](l);
  val v = new Array[T](n);
  def loop(i: Int, l: List[T]) = {
    if (i < n) {
      v(i) = l.head;
      loop(i + 1, l.tail)
    }
  };
  loop(0, l);
  v
};

[error]     at scala.collection.MapLike$class.default(MapLike.scala:228)
[error]     at scala.collection.AbstractMap.default(Map.scala:59)
[error]     at scala.collection.MapLike$class.apply(MapLike.scala:141)
[error]     at scala.collection.AbstractMap.apply(Map.scala:59)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at miniscala.CPSInterpreter.eval(CPSInterpreter.scala:63)
[error]     at miniscala.CPSInterpreter.apply(CPSInterpreter.scala:18)
[error]     at miniscala.CPSInterpreterLow.apply(CPSInterpreter.scala:176)
[error]     at scala.Function1$$anonfun$andThen$1.apply(Function1.scala:52)
[error]     at miniscala.test.infrastructure.CompilerTest$class.miniscala$test$infrastructure$CompilerTest$$compileInner(CompilerTest.scala:37)
[error]     at miniscala.test.infrastructure.CompilerTest$$anonfun$compileUsingPipelineAndRedirect$1.apply(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.SandboxedTest$$anon$1.run(SandboxedTest.scala:24)
[error]     at java.security.AccessController.doPrivileged(Native Method)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTest(SandboxedTest.scala:34)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTestWithRedirectedIO(SandboxedTest.scala:45)
[error]     at miniscala.test.infrastructure.CompilerTest$class.compileUsingPipelineAndRedirect(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.CPSTest.compileUsingPipelineAndRedirect(CPSTest.scala:11)
[error]     at miniscala.test.infrastructure.CPSOptTest.testCPSLowProgramOutput(CPSOptTest.scala:91)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$class.testLibFunctions3(LibraryOKTests.scala:22)
[error]     at miniscala.test.CPSOptimizer_Blackbox.testLibFunctions3(CPSOptimizer_Blackbox.scala:7)
[error]     ...
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveArithmetic1 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveArithmetic2 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveArithmetic3 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveArithmetic4 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveArithmetic5 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveArithmetic6 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic24 started
[error] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic24 failed: assertion failed: 
[error] Output is different: (whitespace is always ignored)
[error] source: 
[error] 
[error] def nl() = putchar(10);
[error] var x = 10;
[error] putchar({ val v = (x != 10); (if (v) 'K' else 'O').toInt });
[error] x = x+1;
[error] putchar({ val v = x == 11; (if (v) 'K' else 'O').toInt });
[error] nl()
[error]                         
[error] output: 
[error] OO
[error] 
[error] expected output: 
[error] OK
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic25 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveBlocks7 started
[error] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveBlocks7 failed: assertion failed: 
[error] Output is different: (whitespace is always ignored)
[error] source: 
[error] 
[error] def nl() = 10.toChar;
[error] val v = "q";
[error] val u = "q";
[error] putchar((if (v == u) 'K' else 'O').toInt);
[error] putchar((if (v != u) 'K' else 'O').toInt);
[error] putchar(nl().toInt)
[error]     
[error] output: 
[error] KO
[error] 
[error] expected output: 
[error] OK
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveBlocks5 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveArithmetic9 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveArithmetic10 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLog20 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic10 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveBlocks1 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveBlocks2 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveArithmetic8 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic12 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic9 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveBlocks3 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic4 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic14 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic15 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic19 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic3 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic22 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic13 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testSideEffectingCondition started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic5 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic11 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLog21 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic23 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveArithmetic7 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic7 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic8 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic16 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic17 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic6 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveBlocks4 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testPrimitiveLogic18 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testLetrec started
def printChar(c: Char) = putchar(c.toInt);

def charRead() = getchar().toChar;

def println() = printChar('\n');

val int0 = '0'.toInt;
val int9 = '9'.toInt;
def isCharDigit(c: Char) = {
  val intC = c.toInt;
  int0 <= intC && intC <= int9
};

def charDigitToInt(c: Char) = c.toInt - int0;

def intCharDigit(i: Int) = (i + int0).toChar;

def functionCompose[T,U,V](f: U => V, g: T => U) = (x: T) => f(g(x));

// Integers

def isEven(i: Int) = 0 == (1 & i);

def isOdd(i: Int) = !isEven(i);

def intAbs(i: Int) = if (i < 0) -i else i;

def intSignum(i: Int) = if (i < 0) -1 else { if (i == 0) 0 else 1 };

def intGcd(x: Int, y: Int) = {
    def auxGcd(x: Int, y: Int): Int = {
      if (0 == y)
        x
      else
        auxGcd(y, x % y)
    };
    auxGcd(intAbs(x), intAbs(y))
};

def intPow(x: Int, y: Int): Int = {
  if (y == 0)
    1
  else {
    if (isEven(y)) {
      val t = intPow(x, y/2);
      t * t
    } else {
      x * intPow(x, y - 1)
    }
  }
};

def intRead() = {
  def aux(accf: (Int, Int) => Int, acc: Int): Int = {
    val c = charRead();
    if (isCharDigit(c)) {
      aux(accf, accf(10 * acc, charDigitToInt(c)))
    } else {
      acc
    }
  };
  val c = charRead();
  if (c == '-') {
    aux((x: Int, y: Int) => x - y, 0)
  } else if (isCharDigit(c)) {
    aux((x: Int, y: Int) => x + y, charDigitToInt(c))
  } else {
    0
  }
};

def printInt(i: Int) = {
  if (i < 0) {
    printChar('-')
  };
  def aux(i: Int): Unit = {
    if (i <= -10)
      aux((i + 9) / 10);
    printChar(intCharDigit(-i % 10))
  };
  aux(if (i < 0) i else -i)
};

def pairDeriveEq[T,U](eq1: (T, T) => Boolean, eq2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => eq1(p1._1, p2._1) && eq2(p1._2, p2._2);

def pairDeriveLt[T,U](lt1: (T, T) => Boolean, lt2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => lt1(p1._1, p2._1) || (!lt1(p1._1, p2._1) && lt2(p1._2, p2._2));

def listMake1[T](e1: T) = e1::Nil;
def listMake2[T](e1: T, e2: T) = e1::listMake1[T](e2);
def listMake3[T](e1: T, e2: T, e3: T) = e1::listMake2[T](e2, e3);
def listMake4[T](e1: T, e2: T, e3: T, e4: T) = e1::listMake3[T](e2, e3, e4);
def listMake5[T](e1: T, e2: T, e3: T, e4: T, e5: T) = e1::listMake4[T](e2, e3, e4, e5);
def listMake6[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T) = e1::listMake5[T](e2, e3, e4, e5, e6);
def listMake7[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T) = e1::listMake6[T](e2, e3, e4, e5, e6, e7);
def listMake8[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T, e8: T) = e1::listMake7[T](e2, e3, e4, e5, e6, e7, e8);

def listTabulate[T](n: Int, f: Int => T) = {
  def aux(i: Int, l: List[T]): List[T] = {
    if (i == 0)
      l
    else
      aux(i - 1, f(i - 1)::l)
  };
  aux(n, Nil)
};

def listLength[T](l: List[T]): Int =
  if (l.isEmpty)
    0
  else
    1 + listLength[T](l.tail);

def listForeach[T](f: T => Unit, l: List[T]): Unit =
  if (!l.isEmpty) {
    f(l.head);
    listForeach[T](f, l.tail)
  };

def listMap[T,U](f: T => U, l: List[T]): List[U] =
  if (l.isEmpty)
    Nil
  else
    f(l.head)::listMap[T,U](f, l.tail);

def listFoldLeft[T,U](f: (T, U) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    listFoldLeft[T,U](f, f(z, l.head), l.tail);

def listFoldRight[T,U](f: (U, T) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    f(l.head, listFoldRight[T,U](f, z, l.tail));

def listEvery[T](p: T => Boolean, l: List[T]): Boolean =
  l.isEmpty || p(l.head) && listEvery[T](p, l.tail);

def listAny[T](p: T => Boolean, l: List[T]): Boolean =
  !l.isEmpty && (p(l.head) || listAny[T](p, l.tail));

def listFilter[T](p: T => Boolean, l: List[T]): List[T] =
  listFoldRight[List[T],T]((e: T, r: List[T]) =>  if (p(e)) e::r else r, Nil, l);

def listPartition[T](p: T => Boolean, l: List[T]) =
  listFoldRight[(List[T], List[T]),T](
    (e: T,  yn: (List[T], List[T])) =>
      if (p(e))
        (e::yn._1, yn._2)
      else
        (yn._1, e::yn._2),
      (Nil, Nil),
      l);

def listTake[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    Nil
  else
    l.head :: listTake[T](l.tail, n - 1);

def listDrop[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    l
  else
    listDrop[T](l.tail, n - 1);

def listNth[T](l: List[T], n: Int): T =
  listDrop[T](l, n).head;

def listReverse[T](l: List[T]): List[T] =
  listFoldLeft[List[T],T]((t: List[T], h: T) => h::t, Nil, l);

def listAppend[T](l1: List[T], l2: List[T]) =
  if (l1.isEmpty) l2
  else if (l2.isEmpty) l1
  else l1.head :: listAppend[T](l1.tail, l2);

def listZip[T,U](l1: List[T], l2: List[U]): List[(T, U)] =
  if (l1.isEmpty  || l2.isEmpty)
    Nil
  else
    (l1.head, l2.head) :: listZip[T,U](l1.tail, l2.tail);

def printString(s: String) = {
  var idx = 0;
  while (idx < s.length) {
    printChar(s(idx));
    idx = idx + 1
  };
  ()
};

def stringConcat(s1: String, s2: String) = {
  val s3 = new Array[Char](s1.length + s2.length);
  var idx = 0;
  while (idx < s1.length) {
    s3(idx) = s1(idx);
    idx = idx + 1
  };
  idx = 0;
  while (idx < s2.length) {
    s3(s1.length + idx) = s2(idx);
    idx = idx + 1
  };
  s3
};

// A PCG random number generator. (Specifically, this is the variant
// called XSH RR in the paper, with a 16-bit state and 8-bit output).
// See http://www.pcg-random.org/

def makeRNG(seed: Int) = {
  val rng = new Array[Int](1);
  rng(0) = seed & 0xFFFF;
  rng
};

def rngGetState(rng: Array[Int]) = rng(0);

def rngSetState(rng: Array[Int], state: Int) = rng(0) = state & 0xFFFF;

def rngRotateRight8(x: Int, y: Int) =
  ((x >> y) | (x << (8 - y))) & 0xFF;

def rngStep(rng: Array[Int]) =
  rngSetState(rng, rngGetState(rng) * 12829 + 47989);

def rngOutput(rng: Array[Int]) = {
  val state = rngGetState(rng);
  rngRotateRight8(0xFF & ((state ^ (state >> 5)) >> 5), state >> 13)
};

// Return the next 8-bit unsigned integer (0 to 255, included)
def rngNextInt8(rng: Array[Int]) = {
  val i = rngOutput(rng);
  rngStep(rng);
  i
};

// FIXME: this is hackish, find a better way to do it (probably using
// multiple streams, see sample/pcg32x2-demo.c in the PCG source).
def rngNextInt(rng: Array[Int]) = {
  val b0 = rngNextInt8(rng);
  val b1 = rngNextInt8(rng);
  val b2 = rngNextInt8(rng);
  val b3 = rngNextInt8(rng);
  (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
};

def arrayTabulate[T](n: Int, f: Int => T) = {
  val v = new Array[T](n);
  var i = 0;
  while (i < n) {
    v(i) = f(i);
    i = i + 1
  };
  v
};

def arraySwap[T](v: Array[T], i1: Int, i2: Int) = {
  val t = v(i1);
  v(i1) = v(i2);
  v(i2) = t
};

def arrayShuffle[T](v: Array[T], seed: Int) = {
  val rng = makeRNG(seed);
  val l = v.length;
  var i = 0;
  while (i < l) {
    val j = i + rngNextInt(rng) % (l - i);
    arraySwap[T](v, i, j);
    i = i + 1
  };
  ()
};

def auxArrayPartition[T](v: Array[T], p: T => Boolean, l: Int, h: Int) = {
  def loop(l: Int, h: Int): Int = {
    if (l >= h)
      l
    else if (p(v(l)))
      loop(l + 1, h)
    else if (!p(v(h-1)))
      loop(l, h - 1)
    else {
      arraySwap[T](v, l, h - 1);
      loop(l + 1, h + 1)
    }
  };
  loop(l, h)
};

// Reorganize the elements of the vector so that all those not
// satisfying the predicate [p] are before those that satisfy it.
// Return the index of the first element not satisfying [p], or the
// length of the vector if all elements satisfy [p].
def arrayPartition[T](v: Array[T], p: T => Boolean) =
  auxArrayPartition[T](v, p, 0, v.length);

def arrayFoldLeft[T,U](f: (T,U) => T, z: T, v: Array[U]) = {
  var i = 0;
  val l = v.length;
  var zz = z;
  while (i < l) {
    zz = f(zz, v(i));
    i = i + 1
  };
  zz
};

def arrayForeach[T](f: T => Unit, v: Array[T]) = {
  var i = 0;
  val l = v.length;
  while (i < l) {
    f(v(i));
    i = i + 1
  };
  ()
};

def arraySort[T](v: Array[T], el: (T, T) => Boolean) = {
  def qsort(l: Int, h: Int) = {
    if (h - l > 0) {
       val p = v(h);
       val pred = (x: T) => el(x, p);
       val m = auxArrayPartition[T](v, pred, l, h);
       arraySwap[T](v, m, h);
       qsort(l, m - 1);
       qsort(m + 1, h)
    }
  };
  qsort(0, v.length - 1)
};

def arrayBinarySearch[T](v: Array[T], e: T, el: (T, T) => Boolean) = {
  def loop(l: Int, h: Int): Int = {
    if (l > h)
      -1 -[error] Test miniscala.test.CPSOptimizer_Blackbox.testLetrec failed: key not found: g
 l
    else {
      val m = l + (h - l) / 2;
      val me = v(m);
      if (el(e, me))
        loop(l, m - 1)
      else if (el(me, e))
        loop(m + 1, h)
      else
        m
    }
  };
  loop(0, v.length - 1)
};

def arrayToList[T](v: Array[T]) = {
  def loop(i: Int): List[T] = {
    if (i == -1)
      Nil
    else
      v(i)::loop(i - 1)
  };
  loop(v.length - 1)
};

def listToArray[T](l: List[T]) = {
  val n = listLength[T](l);
  val v = new Array[T](n);
  def loop(i: Int, l: List[T]) = {
    if (i < n) {
      v(i) = l.head;
      loop(i + 1, l.tail)
    }
  };
  loop(0, l);
  v
};

[error]     at scala.collection.MapLike$class.default(MapLike.scala:228)
[error]     at scala.collection.AbstractMap.default(Map.scala:59)
[error]     at scala.collection.MapLike$class.apply(MapLike.scala:141)
[error]     at scala.collection.AbstractMap.apply(Map.scala:59)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.foreach(List.scala:381)
[error]     at scala.collection.TraversableLike$class.map(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.map(List.scala:285)
[error]     at miniscala.CPSInterpreter.eval(CPSInterpreter.scala:40)
[error]     at miniscala.CPSInterpreter.apply(CPSInterpreter.scala:18)
[error]     at miniscala.CPSInterpreterLow.apply(CPSInterpreter.scala:176)
[error]     at scala.Function1$$anonfun$andThen$1.apply(Function1.scala:52)
[error]     at miniscala.test.infrastructure.CompilerTest$class.miniscala$test$infrastructure$CompilerTest$$compileInner(CompilerTest.scala:37)
[error]     at miniscala.test.infrastructure.CompilerTest$$anonfun$compileUsingPipelineAndRedirect$1.apply(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.SandboxedTest$$anon$1.run(SandboxedTest.scala:24)
[error]     at java.security.AccessController.doPrivileged(Native Method)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTest(SandboxedTest.scala:34)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTestWithRedirectedIO(SandboxedTest.scala:45)
[error]     at miniscala.test.infrastructure.CompilerTest$class.compileUsingPipelineAndRedirect(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.CPSTest.compileUsingPipelineAndRedirect(CPSTest.scala:11)
[error]     at miniscala.test.infrastructure.CPSOptTest.testCPSLowProgramOutput(CPSOptTest.scala:91)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.ConstructsOKTests$class.testLetrec(ConstructsOKTests.scala:20)
[error]     at miniscala.test.CPSOptimizer_Blackbox.testLetrec(CPSOptimizer_Blackbox.scala:7)
[error]     ...
[info] Test miniscala.test.CPSOptimizer_Blackbox.testAppOrder started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists5 started
def printChar(c: Char) = putchar(c.toInt);

def charRead() = getchar().toChar;

def println() = printChar('\n');

val int0 = '0'.toInt;
val int9 = '9'.toInt;
def isCharDigit(c: Char) = {
  val intC = c.toInt;
  int0 <= intC && intC <= int9
};

def charDigitToInt(c: Char) = c.toInt - int0;

def intCharDigit(i: Int) = (i + int0).toChar;

def functionCompose[T,U,V](f: U => V, g: T => U) = (x: T) => f(g(x));

// Integers

def isEven(i: Int) = 0 == (1 & i);

def isOdd(i: Int) = !isEven(i);

def intAbs(i: Int) = if (i < 0) -i else i;

def intSignum(i: Int) = if (i < 0) -1 else { if (i == 0) 0 else 1 };

def intGcd(x: Int, y: Int) = {
    def auxGcd(x: Int, y: Int): Int = {
      if (0 == y)
        x
      else
        auxGcd(y, x % y)
    };
    auxGcd(intAbs(x), intAbs(y))
};

def intPow(x: Int, y: Int): Int = {
  if (y == 0)
    1
  else {
    if (isEven(y)) {
      val t = intPow(x, y/2);
      t * t
    } else {
      x * intPow(x, y - 1)
    }
  }
};

def intRead() = {
  def aux(accf: (Int, Int) => Int, acc: Int): Int = {
    val c = charRead();
    if (isCharDigit(c)) {
      aux(accf, accf(10 * acc, charDigitToInt(c)))
    } else {
      acc
    }
  };
  val c = charRead();
  if (c == '-') {
    aux((x: Int, y: Int) => x - y, 0)
  } else if (isCharDigit(c)) {
    aux((x: Int, y: Int) => x + y, charDigitToInt(c))
  } else {
    0
  }
};

def printInt(i: Int) = {
  if (i < 0) {
    printChar('-')
  };
  def aux(i: Int): Unit = {
    if (i <= -10)
      aux((i + 9) / 10);
    printChar(intCharDigit(-i % 10))
  };
  aux(if (i < 0) i else -i)
};

def pairDeriveEq[T,U](eq1: (T, T) => Boolean, eq2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => eq1(p1._1, p2._1) && eq2(p1._2, p2._2);

def pairDeriveLt[T,U](lt1: (T, T) => Boolean, lt2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => lt1(p1._1, p2._1) || (!lt1(p1._1, p2._1) && lt2(p1._2, p2._2));

def listMake1[T](e1: T) = e1::Nil;
def listMake2[T](e1: T, e2: T) = e1::listMake1[T](e2);
def listMake3[T](e1: T, e2: T, e3: T) = e1::listMake2[T](e2, e3);
def listMake4[T](e1: T, e2: T, e3: T, e4: T) = e1::listMake3[T](e2, e3, e4);
def listMake5[T](e1: T, e2: T, e3: T, e4: T, e5: T) = e1::listMake4[T](e2, e3, e4, e5);
def listMake6[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T) = e1::listMake5[T](e2, e3, e4, e5, e6);
def listMake7[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T) = e1::listMake6[T](e2, e3, e4, e5, e6, e7);
def listMake8[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T, e8: T) = e1::listMake7[T](e2, e3, e4, e5, e6, e7, e8);

def listTabulate[T](n: Int, f: Int => T) = {
  def aux(i: Int, l: List[T]): List[T] = {
    if (i == 0)
      l
    else
      aux(i - 1, f(i - 1)::l)
  };
  aux(n, Nil)
};

def listLength[T](l: List[T]): Int =
  if (l.isEmpty)
    0
  else
    1 + listLength[T](l.tail);

def listForeach[T](f: T => Unit, l: List[T]): Unit =
  if (!l.isEmpty) {
    f(l.head);
    listForeach[T](f, l.tail)
  };

def listMap[T,U](f: T => U, l: List[T]): List[U] =
  if (l.isEmpty)
    Nil
  else
    f(l.head)::listMap[T,U](f, l.tail);

def listFoldLeft[T,U](f: (T, U) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    listFoldLeft[T,U](f, f(z, l.head), l.tail);

def listFoldRight[T,U](f: (U, T) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    f(l.head, listFoldRight[T,U](f, z, l.tail));

def listEvery[T](p: T => Boolean, l: List[T]): Boolean =
  l.isEmpty || p(l.head) && listEvery[T](p, l.tail);

def listAny[T](p: T => Boolean, l: List[T]): Boolean =
  !l.isEmpty && (p(l.head) || listAny[T](p, l.tail));

def listFilter[T](p: T => Boolean, l: List[T]): List[T] =
  listFoldRight[List[T],T]((e: T, r: List[T]) =>  if (p(e)) e::r else r, Nil, l);

def listPartition[T](p: T => Boolean, l: List[T]) =
  listFoldRight[(List[T], List[T]),T](
    (e: T,  yn: (List[T], List[T])) =>
      if (p(e))
        (e::yn._1, yn._2)
      else
        (yn._1, e::yn._2),
      (Nil, Nil),
      l);

def listTake[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    Nil
  else
    l.head :: listTake[T](l.tail, n - 1);

def listDrop[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    l
  else
    listDrop[T](l.tail, n - 1);

def listNth[T](l: List[T], n: Int): T =
  listDrop[T](l, n).head;

def listReverse[T](l: List[T]): List[T] =
  listFoldLeft[List[T],T]((t: List[T], h: T) => h::t, Nil, l);

def listAppend[T](l1: List[T], l2: List[T]) =
  if (l1.isEmpty) l2
  else if (l2.isEmpty) l1
  else l1.head :: listAppend[T](l1.tail, l2);

def listZip[T,U](l1: List[T], l2: List[U]): List[(T, U)] =
  if (l1.isEmpty  || l2.isEmpty)
    Nil
  else
    (l1.head, l2.head) :: listZip[T,U](l1.tail, l2.tail);

def printString(s: String) = {
  var idx = 0;
  while (idx < s.length) {
    printChar(s(idx));
    idx = idx + 1
  };
  ()
};

def stringConcat(s1: String, s2: String) = {
  val s3 = new Array[Char](s1.length + s2.length);
  var idx = 0;
  while (idx < s1.length) {
    s3(idx) = s1(idx);
    idx = idx + 1
  };
  idx = 0;
  while (idx < s2.length) {
    s3(s1.length + idx) = s2(idx);
    idx = idx + 1
  };
  s3
};

// A PCG random number generator. (Specifically, this is the variant
// called XSH RR in the paper, with a 16-bit state and 8-bit output).
// See http://www.pcg-random.org/

def makeRNG(seed: Int) = {
  val rng = new Array[Int](1);
  rng(0) = seed & 0xFFFF;
  rng
};

def rngGetState(rng: Array[Int]) = rng(0);

def rngSetState(rng: Array[Int], state: Int) = rng(0) = state & 0xFFFF;

def rngRotateRight8(x: Int, y: Int) =
  ((x >> y) | (x << (8 - y))) & 0xFF;

def rngStep(rng: Array[Int]) =
  rngSetState(rng, rngGetState(rng) * 12829 + 47989);

def rngOutput(rng: Array[Int]) = {
  val state = rngGetState(rng);
  rngRotateRight8(0xFF & ((state ^ (state >> 5)) >> 5), state >> 13)
};

// Return the next 8-bit unsigned integer (0 to 255, included)
def rngNextInt8(rng: Array[Int]) = {
  val i = rngOutput(rng);
  rngStep(rng);
  i
};

// FIXME: this is hackish, find a better way to do it (probably using
// multiple streams, see sample/pcg32x2-demo.c in the PCG source).
def rngNextInt(rng: Array[Int]) = {
  val b0 = rngNextInt8(rng);
  val b1 = rngNextInt8(rng);
  val b2 = rngNextInt8(rng);
  val b3 = rngNextInt8(rng);
  (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
};

def arrayTabulate[T](n: Int, f: Int => T) = {
  val v = new Array[T](n);
  var i = 0;
  while (i < n) {
    v(i) = f(i);
    i = i + 1
  };
  v
};

def arraySwap[T](v: Array[T], i1: Int, i2: Int) = {
  val t = v(i1);
  v(i1) = v(i2);
  v(i2) = t
};

def arrayShuffle[T](v: Array[T], seed: Int) = {
  val rng = makeRNG(seed);
  val l = v.length;
  var i = 0;
  while (i < l) {
    val j = i + rngNextInt(rng) % (l - i);
    arraySwap[T](v, i, j);
    i = i + 1
  };
  ()
};

def auxArrayPartition[T](v: Array[T], p: T => Boolean, l: Int, h: Int) = {
  def loop(l: Int, h: Int): Int = {
    if (l >= h)
      l
    else if (p(v(l)))
      loop(l + 1, h)
    else if (!p(v(h-1)))
      loop(l, h - 1)
    else {
      arraySwap[T](v, l, h - 1);
      loop(l + 1, h + 1)
    }
  };
  loop(l, h)
};

// Reorganize the elements of the vector so that all those not
// satisfying the predicate [p] are before those that satisfy it.
// Return the index of the first element not satisfying [p], or the
// length of the vector if all elements satisfy [p].
def arrayPartition[T](v: Array[T], p: T => Boolean) =
  auxArrayPartition[T](v, p, 0, v.length);

def arrayFoldLeft[T,U](f: (T,U) => T, z: T, v: Array[U]) = {
  var i = 0;
  val l = v.length;
  var zz = z;
  while (i < l) {
    zz = f(zz, v(i));
    i = i + 1
  };
  zz
};

def arrayForeach[T](f: T => Unit, v: Array[T]) = {
  var i = 0;
  val l = v.length;
  while (i < l) {
    f(v(i));
    i = i + 1
  };
  ()
};

def arraySort[T](v: Array[T], el: (T, T) => Boolean) = {
  def qsort(l: Int, h: Int) = {
    if (h - l > 0) {
       val p = v(h);
       val pred = (x: T) => el(x, p);
       val m = auxArrayPartition[T](v, pred, l, h);
       arraySwap[T](v, m, h);
       qsort(l, m - 1);
       qsort(m + 1, h)
    }
  };
  qsort(0, v.length - 1)
};

def arrayBinarySearch[T](v: Array[T], e: T, el: (T, T) => Boolean) = {
  def loop(l: Int, h: Int): Int = {
    if (l > h)
      -1 -[error] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists5 failed: key not found: fun$30_1
 l
    else {
      val m = l + (h - l) / 2;
      val me = v(m);
      if (el(e, me))
        loop(l, m - 1)
      else if (el(me, e))
        loop(m + 1, h)
      else
        m
    }
  };
  loop(0, v.length - 1)
};

def arrayToList[T](v: Array[T]) = {
  def loop(i: Int): List[T] = {
    if (i == -1)
      Nil
    else
      v(i)::loop(i - 1)
  };
  loop(v.length - 1)
};

def listToArray[T](l: List[T]) = {
  val n = listLength[T](l);
  val v = new Array[T](n);
  def loop(i: Int, l: List[T]) = {
    if (i < n) {
      v(i) = l.head;
      loop(i + 1, l.tail)
    }
  };
  loop(0, l);
  v
};

[error]     at scala.collection.MapLike$class.default(MapLike.scala:228)
[error]     at scala.collection.AbstractMap.default(Map.scala:59)
[error]     at scala.collection.MapLike$class.apply(MapLike.scala:141)
[error]     at scala.collection.AbstractMap.apply(Map.scala:59)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at miniscala.CPSInterpreter.eval(CPSInterpreter.scala:63)
[error]     at miniscala.CPSInterpreter.apply(CPSInterpreter.scala:18)
[error]     at miniscala.CPSInterpreterLow.apply(CPSInterpreter.scala:176)
[error]     at scala.Function1$$anonfun$andThen$1.apply(Function1.scala:52)
[error]     at miniscala.test.infrastructure.CompilerTest$class.miniscala$test$infrastructure$CompilerTest$$compileInner(CompilerTest.scala:37)
[error]     at miniscala.test.infrastructure.CompilerTest$$anonfun$compileUsingPipelineAndRedirect$1.apply(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.SandboxedTest$$anon$1.run(SandboxedTest.scala:24)
[error]     at java.security.AccessController.doPrivileged(Native Method)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTest(SandboxedTest.scala:34)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTestWithRedirectedIO(SandboxedTest.scala:45)
[error]     at miniscala.test.infrastructure.CompilerTest$class.compileUsingPipelineAndRedirect(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.CPSTest.compileUsingPipelineAndRedirect(CPSTest.scala:11)
[error]     at miniscala.test.infrastructure.CPSOptTest.testCPSLowProgramOutput(CPSOptTest.scala:91)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$class.testLibLists5(LibraryOKTests.scala:59)
[error]     at miniscala.test.CPSOptimizer_Blackbox.testLibLists5(CPSOptimizer_Blackbox.scala:7)
[error]     ...
[info] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists6 started
def printChar(c: Char) = putchar(c.toInt);

def charRead() = getchar().toChar;

def println() = printChar('\n');

val int0 = '0'.toInt;
val int9 = '9'.toInt;
def isCharDigit(c: Char) = {
  val intC = c.toInt;
  int0 <= intC && intC <= int9
};

def charDigitToInt(c: Char) = c.toInt - int0;

def intCharDigit(i: Int) = (i + int0).toChar;

def functionCompose[T,U,V](f: U => V, g: T => U) = (x: T) => f(g(x));

// Integers

def isEven(i: Int) = 0 == (1 & i);

def isOdd(i: Int) = !isEven(i);

def intAbs(i: Int) = if (i < 0) -i else i;

def intSignum(i: Int) = if (i < 0) -1 else { if (i == 0) 0 else 1 };

def intGcd(x: Int, y: Int) = {
    def auxGcd(x: Int, y: Int): Int = {
      if (0 == y)
        x
      else
        auxGcd(y, x % y)
    };
    auxGcd(intAbs(x), intAbs(y))
};

def intPow(x: Int, y: Int): Int = {
  if (y == 0)
    1
  else {
    if (isEven(y)) {
      val t = intPow(x, y/2);
      t * t
    } else {
      x * intPow(x, y - 1)
    }
  }
};

def intRead() = {
  def aux(accf: (Int, Int) => Int, acc: Int): Int = {
    val c = charRead();
    if (isCharDigit(c)) {
      aux(accf, accf(10 * acc, charDigitToInt(c)))
    } else {
      acc
    }
  };
  val c = charRead();
  if (c == '-') {
    aux((x: Int, y: Int) => x - y, 0)
  } else if (isCharDigit(c)) {
    aux((x: Int, y: Int) => x + y, charDigitToInt(c))
  } else {
    0
  }
};

def printInt(i: Int) = {
  if (i < 0) {
    printChar('-')
  };
  def aux(i: Int): Unit = {
    if (i <= -10)
      aux((i + 9) / 10);
    printChar(intCharDigit(-i % 10))
  };
  aux(if (i < 0) i else -i)
};

def pairDeriveEq[T,U](eq1: (T, T) => Boolean, eq2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => eq1(p1._1, p2._1) && eq2(p1._2, p2._2);

def pairDeriveLt[T,U](lt1: (T, T) => Boolean, lt2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => lt1(p1._1, p2._1) || (!lt1(p1._1, p2._1) && lt2(p1._2, p2._2));

def listMake1[T](e1: T) = e1::Nil;
def listMake2[T](e1: T, e2: T) = e1::listMake1[T](e2);
def listMake3[T](e1: T, e2: T, e3: T) = e1::listMake2[T](e2, e3);
def listMake4[T](e1: T, e2: T, e3: T, e4: T) = e1::listMake3[T](e2, e3, e4);
def listMake5[T](e1: T, e2: T, e3: T, e4: T, e5: T) = e1::listMake4[T](e2, e3, e4, e5);
def listMake6[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T) = e1::listMake5[T](e2, e3, e4, e5, e6);
def listMake7[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T) = e1::listMake6[T](e2, e3, e4, e5, e6, e7);
def listMake8[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T, e8: T) = e1::listMake7[T](e2, e3, e4, e5, e6, e7, e8);

def listTabulate[T](n: Int, f: Int => T) = {
  def aux(i: Int, l: List[T]): List[T] = {
    if (i == 0)
      l
    else
      aux(i - 1, f(i - 1)::l)
  };
  aux(n, Nil)
};

def listLength[T](l: List[T]): Int =
  if (l.isEmpty)
    0
  else
    1 + listLength[T](l.tail);

def listForeach[T](f: T => Unit, l: List[T]): Unit =
  if (!l.isEmpty) {
    f(l.head);
    listForeach[T](f, l.tail)
  };

def listMap[T,U](f: T => U, l: List[T]): List[U] =
  if (l.isEmpty)
    Nil
  else
    f(l.head)::listMap[T,U](f, l.tail);

def listFoldLeft[T,U](f: (T, U) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    listFoldLeft[T,U](f, f(z, l.head), l.tail);

def listFoldRight[T,U](f: (U, T) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    f(l.head, listFoldRight[T,U](f, z, l.tail));

def listEvery[T](p: T => Boolean, l: List[T]): Boolean =
  l.isEmpty || p(l.head) && listEvery[T](p, l.tail);

def listAny[T](p: T => Boolean, l: List[T]): Boolean =
  !l.isEmpty && (p(l.head) || listAny[T](p, l.tail));

def listFilter[T](p: T => Boolean, l: List[T]): List[T] =
  listFoldRight[List[T],T]((e: T, r: List[T]) =>  if (p(e)) e::r else r, Nil, l);

def listPartition[T](p: T => Boolean, l: List[T]) =
  listFoldRight[(List[T], List[T]),T](
    (e: T,  yn: (List[T], List[T])) =>
      if (p(e))
        (e::yn._1, yn._2)
      else
        (yn._1, e::yn._2),
      (Nil, Nil),
      l);

def listTake[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    Nil
  else
    l.head :: listTake[T](l.tail, n - 1);

def listDrop[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    l
  else
    listDrop[T](l.tail, n - 1);

def listNth[T](l: List[T], n: Int): T =
  listDrop[T](l, n).head;

def listReverse[T](l: List[T]): List[T] =
  listFoldLeft[List[T],T]((t: List[T], h: T) => h::t, Nil, l);

def listAppend[T](l1: List[T], l2: List[T]) =
  if (l1.isEmpty) l2
  else if (l2.isEmpty) l1
  else l1.head :: listAppend[T](l1.tail, l2);

def listZip[T,U](l1: List[T], l2: List[U]): List[(T, U)] =
  if (l1.isEmpty  || l2.isEmpty)
    Nil
  else
    (l1.head, l2.head) :: listZip[T,U](l1.tail, l2.tail);

def printString(s: String) = {
  var idx = 0;
  while (idx < s.length) {
    printChar(s(idx));
    idx = idx + 1
  };
  ()
};

def stringConcat(s1: String, s2: String) = {
  val s3 = new Array[Char](s1.length + s2.length);
  var idx = 0;
  while (idx < s1.length) {
    s3(idx) = s1(idx);
    idx = idx + 1
  };
  idx = 0;
  while (idx < s2.length) {
    s3(s1.length + idx) = s2(idx);
    idx = idx + 1
  };
  s3
};

// A PCG random number generator. (Specifically, this is the variant
// called XSH RR in the paper, with a 16-bit state and 8-bit output).
// See http://www.pcg-random.org/

def makeRNG(seed: Int) = {
  val rng = new Array[Int](1);
  rng(0) = seed & 0xFFFF;
  rng
};

def rngGetState(rng: Array[Int]) = rng(0);

def rngSetState(rng: Array[Int], state: Int) = rng(0) = state & 0xFFFF;

def rngRotateRight8(x: Int, y: Int) =
  ((x >> y) | (x << (8 - y))) & 0xFF;

def rngStep(rng: Array[Int]) =
  rngSetState(rng, rngGetState(rng) * 12829 + 47989);

def rngOutput(rng: Array[Int]) = {
  val state = rngGetState(rng);
  rngRotateRight8(0xFF & ((state ^ (state >> 5)) >> 5), state >> 13)
};

// Return the next 8-bit unsigned integer (0 to 255, included)
def rngNextInt8(rng: Array[Int]) = {
  val i = rngOutput(rng);
  rngStep(rng);
  i
};

// FIXME: this is hackish, find a better way to do it (probably using
// multiple streams, see sample/pcg32x2-demo.c in the PCG source).
def rngNextInt(rng: Array[Int]) = {
  val b0 = rngNextInt8(rng);
  val b1 = rngNextInt8(rng);
  val b2 = rngNextInt8(rng);
  val b3 = rngNextInt8(rng);
  (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
};

def arrayTabulate[T](n: Int, f: Int => T) = {
  val v = new Array[T](n);
  var i = 0;
  while (i < n) {
    v(i) = f(i);
    i = i + 1
  };
  v
};

def arraySwap[T](v: Array[T], i1: Int, i2: Int) = {
  val t = v(i1);
  v(i1) = v(i2);
  v(i2) = t
};

def arrayShuffle[T](v: Array[T], seed: Int) = {
  val rng = makeRNG(seed);
  val l = v.length;
  var i = 0;
  while (i < l) {
    val j = i + rngNextInt(rng) % (l - i);
    arraySwap[T](v, i, j);
    i = i + 1
  };
  ()
};

def auxArrayPartition[T](v: Array[T], p: T => Boolean, l: Int, h: Int) = {
  def loop(l: Int, h: Int): Int = {
    if (l >= h)
      l
    else if (p(v(l)))
      loop(l + 1, h)
    else if (!p(v(h-1)))
      loop(l, h - 1)
    else {
      arraySwap[T](v, l, h - 1);
      loop(l + 1, h + 1)
    }
  };
  loop(l, h)
};

// Reorganize the elements of the vector so that all those not
// satisfying the predicate [p] are before those that satisfy it.
// Return the index of the first element not satisfying [p], or the
// length of the vector if all elements satisfy [p].
def arrayPartition[T](v: Array[T], p: T => Boolean) =
  auxArrayPartition[T](v, p, 0, v.length);

def arrayFoldLeft[T,U](f: (T,U) => T, z: T, v: Array[U]) = {
  var i = 0;
  val l = v.length;
  var zz = z;
  while (i < l) {
    zz = f(zz, v(i));
    i = i + 1
  };
  zz
};

def arrayForeach[T](f: T => Unit, v: Array[T]) = {
  var i = 0;
  val l = v.length;
  while (i < l) {
    f(v(i));
    i = i + 1
  };
  ()
};

def arraySort[T](v: Array[T], el: (T, T) => Boolean) = {
  def qsort(l: Int, h: Int) = {
    if (h - l > 0) {
       val p = v(h);
       val pred = (x: T) => el(x, p);
       val m = auxArrayPartition[T](v, pred, l, h);
       arraySwap[T](v, m, h);
       qsort(l, m - 1);
       qsort(m + 1, h)
    }
  };
  qsort(0, v.length - 1)
};

def arrayBinarySearch[T](v: Array[T], e: T, el: (T, T) => Boolean) = {
  def loop(l: Int, h: Int): Int = {
    if (l > h)
      -1 -[error] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists6 failed: key not found: fun$30_2
 l
    else {
      val m = l + (h - l) / 2;
      val me = v(m);
      if (el(e, me))
        loop(l, m - 1)
      else if (el(me, e))
        loop(m + 1, h)
      else
        m
    }
  };
  loop(0, v.length - 1)
};

def arrayToList[T](v: Array[T]) = {
  def loop(i: Int): List[T] = {
    if (i == -1)
      Nil
    else
      v(i)::loop(i - 1)
  };
  loop(v.length - 1)
};

def listToArray[T](l: List[T]) = {
  val n = listLength[T](l);
  val v = new Array[T](n);
  def loop(i: Int, l: List[T]) = {
    if (i < n) {
      v(i) = l.head;
      loop(i + 1, l.tail)
    }
  };
  loop(0, l);
  v
};

[error]     at scala.collection.MapLike$class.default(MapLike.scala:228)
[error]     at scala.collection.AbstractMap.default(Map.scala:59)
[error]     at scala.collection.MapLike$class.apply(MapLike.scala:141)
[error]     at scala.collection.AbstractMap.apply(Map.scala:59)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at miniscala.CPSInterpreter.eval(CPSInterpreter.scala:63)
[error]     at miniscala.CPSInterpreter.apply(CPSInterpreter.scala:18)
[error]     at miniscala.CPSInterpreterLow.apply(CPSInterpreter.scala:176)
[error]     at scala.Function1$$anonfun$andThen$1.apply(Function1.scala:52)
[error]     at miniscala.test.infrastructure.CompilerTest$class.miniscala$test$infrastructure$CompilerTest$$compileInner(CompilerTest.scala:37)
[error]     at miniscala.test.infrastructure.CompilerTest$$anonfun$compileUsingPipelineAndRedirect$1.apply(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.SandboxedTest$$anon$1.run(SandboxedTest.scala:24)
[error]     at java.security.AccessController.doPrivileged(Native Method)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTest(SandboxedTest.scala:34)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTestWithRedirectedIO(SandboxedTest.scala:45)
[error]     at miniscala.test.infrastructure.CompilerTest$class.compileUsingPipelineAndRedirect(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.CPSTest.compileUsingPipelineAndRedirect(CPSTest.scala:11)
[error]     at miniscala.test.infrastructure.CPSOptTest.testCPSLowProgramOutput(CPSOptTest.scala:91)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$class.testLibLists6(LibraryOKTests.scala:71)
[error]     at miniscala.test.CPSOptimizer_Blackbox.testLibLists6(CPSOptimizer_Blackbox.scala:7)
[error]     ...
[info] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists7 started
def printChar(c: Char) = putchar(c.toInt);

def charRead() = getchar().toChar;

def println() = printChar('\n');

val int0 = '0'.toInt;
val int9 = '9'.toInt;
def isCharDigit(c: Char) = {
  val intC = c.toInt;
  int0 <= intC && intC <= int9
};

def charDigitToInt(c: Char) = c.toInt - int0;

def intCharDigit(i: Int) = (i + int0).toChar;

def functionCompose[T,U,V](f: U => V, g: T => U) = (x: T) => f(g(x));

// Integers

def isEven(i: Int) = 0 == (1 & i);

def isOdd(i: Int) = !isEven(i);

def intAbs(i: Int) = if (i < 0) -i else i;

def intSignum(i: Int) = if (i < 0) -1 else { if (i == 0) 0 else 1 };

def intGcd(x: Int, y: Int) = {
    def auxGcd(x: Int, y: Int): Int = {
      if (0 == y)
        x
      else
        auxGcd(y, x % y)
    };
    auxGcd(intAbs(x), intAbs(y))
};

def intPow(x: Int, y: Int): Int = {
  if (y == 0)
    1
  else {
    if (isEven(y)) {
      val t = intPow(x, y/2);
      t * t
    } else {
      x * intPow(x, y - 1)
    }
  }
};

def intRead() = {
  def aux(accf: (Int, Int) => Int, acc: Int): Int = {
    val c = charRead();
    if (isCharDigit(c)) {
      aux(accf, accf(10 * acc, charDigitToInt(c)))
    } else {
      acc
    }
  };
  val c = charRead();
  if (c == '-') {
    aux((x: Int, y: Int) => x - y, 0)
  } else if (isCharDigit(c)) {
    aux((x: Int, y: Int) => x + y, charDigitToInt(c))
  } else {
    0
  }
};

def printInt(i: Int) = {
  if (i < 0) {
    printChar('-')
  };
  def aux(i: Int): Unit = {
    if (i <= -10)
      aux((i + 9) / 10);
    printChar(intCharDigit(-i % 10))
  };
  aux(if (i < 0) i else -i)
};

def pairDeriveEq[T,U](eq1: (T, T) => Boolean, eq2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => eq1(p1._1, p2._1) && eq2(p1._2, p2._2);

def pairDeriveLt[T,U](lt1: (T, T) => Boolean, lt2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => lt1(p1._1, p2._1) || (!lt1(p1._1, p2._1) && lt2(p1._2, p2._2));

def listMake1[T](e1: T) = e1::Nil;
def listMake2[T](e1: T, e2: T) = e1::listMake1[T](e2);
def listMake3[T](e1: T, e2: T, e3: T) = e1::listMake2[T](e2, e3);
def listMake4[T](e1: T, e2: T, e3: T, e4: T) = e1::listMake3[T](e2, e3, e4);
def listMake5[T](e1: T, e2: T, e3: T, e4: T, e5: T) = e1::listMake4[T](e2, e3, e4, e5);
def listMake6[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T) = e1::listMake5[T](e2, e3, e4, e5, e6);
def listMake7[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T) = e1::listMake6[T](e2, e3, e4, e5, e6, e7);
def listMake8[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T, e8: T) = e1::listMake7[T](e2, e3, e4, e5, e6, e7, e8);

def listTabulate[T](n: Int, f: Int => T) = {
  def aux(i: Int, l: List[T]): List[T] = {
    if (i == 0)
      l
    else
      aux(i - 1, f(i - 1)::l)
  };
  aux(n, Nil)
};

def listLength[T](l: List[T]): Int =
  if (l.isEmpty)
    0
  else
    1 + listLength[T](l.tail);

def listForeach[T](f: T => Unit, l: List[T]): Unit =
  if (!l.isEmpty) {
    f(l.head);
    listForeach[T](f, l.tail)
  };

def listMap[T,U](f: T => U, l: List[T]): List[U] =
  if (l.isEmpty)
    Nil
  else
    f(l.head)::listMap[T,U](f, l.tail);

def listFoldLeft[T,U](f: (T, U) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    listFoldLeft[T,U](f, f(z, l.head), l.tail);

def listFoldRight[T,U](f: (U, T) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    f(l.head, listFoldRight[T,U](f, z, l.tail));

def listEvery[T](p: T => Boolean, l: List[T]): Boolean =
  l.isEmpty || p(l.head) && listEvery[T](p, l.tail);

def listAny[T](p: T => Boolean, l: List[T]): Boolean =
  !l.isEmpty && (p(l.head) || listAny[T](p, l.tail));

def listFilter[T](p: T => Boolean, l: List[T]): List[T] =
  listFoldRight[List[T],T]((e: T, r: List[T]) =>  if (p(e)) e::r else r, Nil, l);

def listPartition[T](p: T => Boolean, l: List[T]) =
  listFoldRight[(List[T], List[T]),T](
    (e: T,  yn: (List[T], List[T])) =>
      if (p(e))
        (e::yn._1, yn._2)
      else
        (yn._1, e::yn._2),
      (Nil, Nil),
      l);

def listTake[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    Nil
  else
    l.head :: listTake[T](l.tail, n - 1);

def listDrop[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    l
  else
    listDrop[T](l.tail, n - 1);

def listNth[T](l: List[T], n: Int): T =
  listDrop[T](l, n).head;

def listReverse[T](l: List[T]): List[T] =
  listFoldLeft[List[T],T]((t: List[T], h: T) => h::t, Nil, l);

def listAppend[T](l1: List[T], l2: List[T]) =
  if (l1.isEmpty) l2
  else if (l2.isEmpty) l1
  else l1.head :: listAppend[T](l1.tail, l2);

def listZip[T,U](l1: List[T], l2: List[U]): List[(T, U)] =
  if (l1.isEmpty  || l2.isEmpty)
    Nil
  else
    (l1.head, l2.head) :: listZip[T,U](l1.tail, l2.tail);

def printString(s: String) = {
  var idx = 0;
  while (idx < s.length) {
    printChar(s(idx));
    idx = idx + 1
  };
  ()
};

def stringConcat(s1: String, s2: String) = {
  val s3 = new Array[Char](s1.length + s2.length);
  var idx = 0;
  while (idx < s1.length) {
    s3(idx) = s1(idx);
    idx = idx + 1
  };
  idx = 0;
  while (idx < s2.length) {
    s3(s1.length + idx) = s2(idx);
    idx = idx + 1
  };
  s3
};

// A PCG random number generator. (Specifically, this is the variant
// called XSH RR in the paper, with a 16-bit state and 8-bit output).
// See http://www.pcg-random.org/

def makeRNG(seed: Int) = {
  val rng = new Array[Int](1);
  rng(0) = seed & 0xFFFF;
  rng
};

def rngGetState(rng: Array[Int]) = rng(0);

def rngSetState(rng: Array[Int], state: Int) = rng(0) = state & 0xFFFF;

def rngRotateRight8(x: Int, y: Int) =
  ((x >> y) | (x << (8 - y))) & 0xFF;

def rngStep(rng: Array[Int]) =
  rngSetState(rng, rngGetState(rng) * 12829 + 47989);

def rngOutput(rng: Array[Int]) = {
  val state = rngGetState(rng);
  rngRotateRight8(0xFF & ((state ^ (state >> 5)) >> 5), state >> 13)
};

// Return the next 8-bit unsigned integer (0 to 255, included)
def rngNextInt8(rng: Array[Int]) = {
  val i = rngOutput(rng);
  rngStep(rng);
  i
};

// FIXME: this is hackish, find a better way to do it (probably using
// multiple streams, see sample/pcg32x2-demo.c in the PCG source).
def rngNextInt(rng: Array[Int]) = {
  val b0 = rngNextInt8(rng);
  val b1 = rngNextInt8(rng);
  val b2 = rngNextInt8(rng);
  val b3 = rngNextInt8(rng);
  (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
};

def arrayTabulate[T](n: Int, f: Int => T) = {
  val v = new Array[T](n);
  var i = 0;
  while (i < n) {
    v(i) = f(i);
    i = i + 1
  };
  v
};

def arraySwap[T](v: Array[T], i1: Int, i2: Int) = {
  val t = v(i1);
  v(i1) = v(i2);
  v(i2) = t
};

def arrayShuffle[T](v: Array[T], seed: Int) = {
  val rng = makeRNG(seed);
  val l = v.length;
  var i = 0;
  while (i < l) {
    val j = i + rngNextInt(rng) % (l - i);
    arraySwap[T](v, i, j);
    i = i + 1
  };
  ()
};

def auxArrayPartition[T](v: Array[T], p: T => Boolean, l: Int, h: Int) = {
  def loop(l: Int, h: Int): Int = {
    if (l >= h)
      l
    else if (p(v(l)))
      loop(l + 1, h)
    else if (!p(v(h-1)))
      loop(l, h - 1)
    else {
      arraySwap[T](v, l, h - 1);
      loop(l + 1, h + 1)
    }
  };
  loop(l, h)
};

// Reorganize the elements of the vector so that all those not
// satisfying the predicate [p] are before those that satisfy it.
// Return the index of the first element not satisfying [p], or the
// length of the vector if all elements satisfy [p].
def arrayPartition[T](v: Array[T], p: T => Boolean) =
  auxArrayPartition[T](v, p, 0, v.length);

def arrayFoldLeft[T,U](f: (T,U) => T, z: T, v: Array[U]) = {
  var i = 0;
  val l = v.length;
  var zz = z;
  while (i < l) {
    zz = f(zz, v(i));
    i = i + 1
  };
  zz
};

def arrayForeach[T](f: T => Unit, v: Array[T]) = {
  var i = 0;
  val l = v.length;
  while (i < l) {
    f(v(i));
    i = i + 1
  };
  ()
};

def arraySort[T](v: Array[T], el: (T, T) => Boolean) = {
  def qsort(l: Int, h: Int) = {
    if (h - l > 0) {
       val p = v(h);
       val pred = (x: T) => el(x, p);
       val m = auxArrayPartition[T](v, pred, l, h);
       arraySwap[T](v, m, h);
       qsort(l, m - 1);
       qsort(m + 1, h)
    }
  };
  qsort(0, v.length - 1)
};

def arrayBinarySearch[T](v: Array[T], e: T, el: (T, T) => Boolean) = {
  def loop(l: Int, h: Int): Int = {
    if (l > h)
      -1 -[error] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists7 failed: key not found: listMake7
 l
    else {
      val m = l + (h - l) / 2;
      val me = v(m);
      if (el(e, me))
        loop(l, m - 1)
      else if (el(me, e))
        loop(m + 1, h)
      else
        m
    }
  };
  loop(0, v.length - 1)
};

def arrayToList[T](v: Array[T]) = {
  def loop(i: Int): List[T] = {
    if (i == -1)
      Nil
    else
      v(i)::loop(i - 1)
  };
  loop(v.length - 1)
};

def listToArray[T](l: List[T]) = {
  val n = listLength[T](l);
  val v = new Array[T](n);
  def loop(i: Int, l: List[T]) = {
    if (i < n) {
      v(i) = l.head;
      loop(i + 1, l.tail)
    }
  };
  loop(0, l);
  v
};

[error]     at scala.collection.MapLike$class.default(MapLike.scala:228)
[error]     at scala.collection.AbstractMap.default(Map.scala:59)
[error]     at scala.collection.MapLike$class.apply(MapLike.scala:141)
[error]     at scala.collection.AbstractMap.apply(Map.scala:59)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.foreach(List.scala:381)
[error]     at scala.collection.TraversableLike$class.map(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.map(List.scala:285)
[error]     at miniscala.CPSInterpreter.eval(CPSInterpreter.scala:40)
[error]     at miniscala.CPSInterpreter.apply(CPSInterpreter.scala:18)
[error]     at miniscala.CPSInterpreterLow.apply(CPSInterpreter.scala:176)
[error]     at scala.Function1$$anonfun$andThen$1.apply(Function1.scala:52)
[error]     at miniscala.test.infrastructure.CompilerTest$class.miniscala$test$infrastructure$CompilerTest$$compileInner(CompilerTest.scala:37)
[error]     at miniscala.test.infrastructure.CompilerTest$$anonfun$compileUsingPipelineAndRedirect$1.apply(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.SandboxedTest$$anon$1.run(SandboxedTest.scala:24)
[error]     at java.security.AccessController.doPrivileged(Native Method)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTest(SandboxedTest.scala:34)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTestWithRedirectedIO(SandboxedTest.scala:45)
[error]     at miniscala.test.infrastructure.CompilerTest$class.compileUsingPipelineAndRedirect(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.CPSTest.compileUsingPipelineAndRedirect(CPSTest.scala:11)
[error]     at miniscala.test.infrastructure.CPSOptTest.testCPSLowProgramOutput(CPSOptTest.scala:91)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$class.testLibLists7(LibraryOKTests.scala:83)
[error]     at miniscala.test.CPSOptimizer_Blackbox.testLibLists7(CPSOptimizer_Blackbox.scala:7)
[error]     ...
[info] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists2 started
def printChar(c: Char) = putchar(c.toInt);

def charRead() = getchar().toChar;

def println() = printChar('\n');

val int0 = '0'.toInt;
val int9 = '9'.toInt;
def isCharDigit(c: Char) = {
  val intC = c.toInt;
  int0 <= intC && intC <= int9
};

def charDigitToInt(c: Char) = c.toInt - int0;

def intCharDigit(i: Int) = (i + int0).toChar;

def functionCompose[T,U,V](f: U => V, g: T => U) = (x: T) => f(g(x));

// Integers

def isEven(i: Int) = 0 == (1 & i);

def isOdd(i: Int) = !isEven(i);

def intAbs(i: Int) = if (i < 0) -i else i;

def intSignum(i: Int) = if (i < 0) -1 else { if (i == 0) 0 else 1 };

def intGcd(x: Int, y: Int) = {
    def auxGcd(x: Int, y: Int): Int = {
      if (0 == y)
        x
      else
        auxGcd(y, x % y)
    };
    auxGcd(intAbs(x), intAbs(y))
};

def intPow(x: Int, y: Int): Int = {
  if (y == 0)
    1
  else {
    if (isEven(y)) {
      val t = intPow(x, y/2);
      t * t
    } else {
      x * intPow(x, y - 1)
    }
  }
};

def intRead() = {
  def aux(accf: (Int, Int) => Int, acc: Int): Int = {
    val c = charRead();
    if (isCharDigit(c)) {
      aux(accf, accf(10 * acc, charDigitToInt(c)))
    } else {
      acc
    }
  };
  val c = charRead();
  if (c == '-') {
    aux((x: Int, y: Int) => x - y, 0)
  } else if (isCharDigit(c)) {
    aux((x: Int, y: Int) => x + y, charDigitToInt(c))
  } else {
    0
  }
};

def printInt(i: Int) = {
  if (i < 0) {
    printChar('-')
  };
  def aux(i: Int): Unit = {
    if (i <= -10)
      aux((i + 9) / 10);
    printChar(intCharDigit(-i % 10))
  };
  aux(if (i < 0) i else -i)
};

def pairDeriveEq[T,U](eq1: (T, T) => Boolean, eq2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => eq1(p1._1, p2._1) && eq2(p1._2, p2._2);

def pairDeriveLt[T,U](lt1: (T, T) => Boolean, lt2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => lt1(p1._1, p2._1) || (!lt1(p1._1, p2._1) && lt2(p1._2, p2._2));

def listMake1[T](e1: T) = e1::Nil;
def listMake2[T](e1: T, e2: T) = e1::listMake1[T](e2);
def listMake3[T](e1: T, e2: T, e3: T) = e1::listMake2[T](e2, e3);
def listMake4[T](e1: T, e2: T, e3: T, e4: T) = e1::listMake3[T](e2, e3, e4);
def listMake5[T](e1: T, e2: T, e3: T, e4: T, e5: T) = e1::listMake4[T](e2, e3, e4, e5);
def listMake6[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T) = e1::listMake5[T](e2, e3, e4, e5, e6);
def listMake7[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T) = e1::listMake6[T](e2, e3, e4, e5, e6, e7);
def listMake8[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T, e8: T) = e1::listMake7[T](e2, e3, e4, e5, e6, e7, e8);

def listTabulate[T](n: Int, f: Int => T) = {
  def aux(i: Int, l: List[T]): List[T] = {
    if (i == 0)
      l
    else
      aux(i - 1, f(i - 1)::l)
  };
  aux(n, Nil)
};

def listLength[T](l: List[T]): Int =
  if (l.isEmpty)
    0
  else
    1 + listLength[T](l.tail);

def listForeach[T](f: T => Unit, l: List[T]): Unit =
  if (!l.isEmpty) {
    f(l.head);
    listForeach[T](f, l.tail)
  };

def listMap[T,U](f: T => U, l: List[T]): List[U] =
  if (l.isEmpty)
    Nil
  else
    f(l.head)::listMap[T,U](f, l.tail);

def listFoldLeft[T,U](f: (T, U) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    listFoldLeft[T,U](f, f(z, l.head), l.tail);

def listFoldRight[T,U](f: (U, T) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    f(l.head, listFoldRight[T,U](f, z, l.tail));

def listEvery[T](p: T => Boolean, l: List[T]): Boolean =
  l.isEmpty || p(l.head) && listEvery[T](p, l.tail);

def listAny[T](p: T => Boolean, l: List[T]): Boolean =
  !l.isEmpty && (p(l.head) || listAny[T](p, l.tail));

def listFilter[T](p: T => Boolean, l: List[T]): List[T] =
  listFoldRight[List[T],T]((e: T, r: List[T]) =>  if (p(e)) e::r else r, Nil, l);

def listPartition[T](p: T => Boolean, l: List[T]) =
  listFoldRight[(List[T], List[T]),T](
    (e: T,  yn: (List[T], List[T])) =>
      if (p(e))
        (e::yn._1, yn._2)
      else
        (yn._1, e::yn._2),
      (Nil, Nil),
      l);

def listTake[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    Nil
  else
    l.head :: listTake[T](l.tail, n - 1);

def listDrop[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    l
  else
    listDrop[T](l.tail, n - 1);

def listNth[T](l: List[T], n: Int): T =
  listDrop[T](l, n).head;

def listReverse[T](l: List[T]): List[T] =
  listFoldLeft[List[T],T]((t: List[T], h: T) => h::t, Nil, l);

def listAppend[T](l1: List[T], l2: List[T]) =
  if (l1.isEmpty) l2
  else if (l2.isEmpty) l1
  else l1.head :: listAppend[T](l1.tail, l2);

def listZip[T,U](l1: List[T], l2: List[U]): List[(T, U)] =
  if (l1.isEmpty  || l2.isEmpty)
    Nil
  else
    (l1.head, l2.head) :: listZip[T,U](l1.tail, l2.tail);

def printString(s: String) = {
  var idx = 0;
  while (idx < s.length) {
    printChar(s(idx));
    idx = idx + 1
  };
  ()
};

def stringConcat(s1: String, s2: String) = {
  val s3 = new Array[Char](s1.length + s2.length);
  var idx = 0;
  while (idx < s1.length) {
    s3(idx) = s1(idx);
    idx = idx + 1
  };
  idx = 0;
  while (idx < s2.length) {
    s3(s1.length + idx) = s2(idx);
    idx = idx + 1
  };
  s3
};

// A PCG random number generator. (Specifically, this is the variant
// called XSH RR in the paper, with a 16-bit state and 8-bit output).
// See http://www.pcg-random.org/

def makeRNG(seed: Int) = {
  val rng = new Array[Int](1);
  rng(0) = seed & 0xFFFF;
  rng
};

def rngGetState(rng: Array[Int]) = rng(0);

def rngSetState(rng: Array[Int], state: Int) = rng(0) = state & 0xFFFF;

def rngRotateRight8(x: Int, y: Int) =
  ((x >> y) | (x << (8 - y))) & 0xFF;

def rngStep(rng: Array[Int]) =
  rngSetState(rng, rngGetState(rng) * 12829 + 47989);

def rngOutput(rng: Array[Int]) = {
  val state = rngGetState(rng);
  rngRotateRight8(0xFF & ((state ^ (state >> 5)) >> 5), state >> 13)
};

// Return the next 8-bit unsigned integer (0 to 255, included)
def rngNextInt8(rng: Array[Int]) = {
  val i = rngOutput(rng);
  rngStep(rng);
  i
};

// FIXME: this is hackish, find a better way to do it (probably using
// multiple streams, see sample/pcg32x2-demo.c in the PCG source).
def rngNextInt(rng: Array[Int]) = {
  val b0 = rngNextInt8(rng);
  val b1 = rngNextInt8(rng);
  val b2 = rngNextInt8(rng);
  val b3 = rngNextInt8(rng);
  (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
};

def arrayTabulate[T](n: Int, f: Int => T) = {
  val v = new Array[T](n);
  var i = 0;
  while (i < n) {
    v(i) = f(i);
    i = i + 1
  };
  v
};

def arraySwap[T](v: Array[T], i1: Int, i2: Int) = {
  val t = v(i1);
  v(i1) = v(i2);
  v(i2) = t
};

def arrayShuffle[T](v: Array[T], seed: Int) = {
  val rng = makeRNG(seed);
  val l = v.length;
  var i = 0;
  while (i < l) {
    val j = i + rngNextInt(rng) % (l - i);
    arraySwap[T](v, i, j);
    i = i + 1
  };
  ()
};

def auxArrayPartition[T](v: Array[T], p: T => Boolean, l: Int, h: Int) = {
  def loop(l: Int, h: Int): Int = {
    if (l >= h)
      l
    else if (p(v(l)))
      loop(l + 1, h)
    else if (!p(v(h-1)))
      loop(l, h - 1)
    else {
      arraySwap[T](v, l, h - 1);
      loop(l + 1, h + 1)
    }
  };
  loop(l, h)
};

// Reorganize the elements of the vector so that all those not
// satisfying the predicate [p] are before those that satisfy it.
// Return the index of the first element not satisfying [p], or the
// length of the vector if all elements satisfy [p].
def arrayPartition[T](v: Array[T], p: T => Boolean) =
  auxArrayPartition[T](v, p, 0, v.length);

def arrayFoldLeft[T,U](f: (T,U) => T, z: T, v: Array[U]) = {
  var i = 0;
  val l = v.length;
  var zz = z;
  while (i < l) {
    zz = f(zz, v(i));
    i = i + 1
  };
  zz
};

def arrayForeach[T](f: T => Unit, v: Array[T]) = {
  var i = 0;
  val l = v.length;
  while (i < l) {
    f(v(i));
    i = i + 1
  };
  ()
};

def arraySort[T](v: Array[T], el: (T, T) => Boolean) = {
  def qsort(l: Int, h: Int) = {
    if (h - l > 0) {
       val p = v(h);
       val pred = (x: T) => el(x, p);
       val m = auxArrayPartition[T](v, pred, l, h);
       arraySwap[T](v, m, h);
       qsort(l, m - 1);
       qsort(m + 1, h)
    }
  };
  qsort(0, v.length - 1)
};

def arrayBinarySearch[T](v: Array[T], e: T, el: (T, T) => Boolean) = {
  def loop(l: Int, h: Int): Int = {
    if (l > h)
      -1 -[error] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists2 failed: assertion failed: 
[error] Output is different: (whitespace is always ignored)
[error] source: 
[error] def printChar(c: Char) = putchar(c.toInt);
[error] 
[error] def charRead() = getchar().toChar;
[error] 
[error] def println() = printChar('\n');
[error] 
[error] val int0 = '0'.toInt;
[error] val int9 = '9'.toInt;
[error] def isCharDigit(c: Char) = {
[error]   val intC = c.toInt;
[error]   int0 <= intC && intC <= int9
[error] };
[error] 
[error] def charDigitToInt(c: Char) = c.toInt - int0;
[error] 
[error] def intCharDigit(i: Int) = (i + int0).toChar;
[error] 
[error] def functionCompose[T,U,V](f: U => V, g: T => U) = (x: T) => f(g(x));
[error] 
[error] // Integers
[error] 
[error] def isEven(i: Int) = 0 == (1 & i);
[error] 
[error] def isOdd(i: Int) = !isEven(i);
[error] 
[error] def intAbs(i: Int) = if (i < 0) -i else i;
[error] 
[error] def intSignum(i: Int) = if (i < 0) -1 else { if (i == 0) 0 else 1 };
[error] 
[error] def intGcd(x: Int, y: Int) = {
[error]     def auxGcd(x: Int, y: Int): Int = {
[error]       if (0 == y)
[error]         x
[error]       else
[error]         auxGcd(y, x % y)
[error]     };
[error]     auxGcd(intAbs(x), intAbs(y))
[error] };
[error] 
[error] def intPow(x: Int, y: Int): Int = {
[error]   if (y == 0)
[error]     1
[error]   else {
[error]     if (isEven(y)) {
[error]       val t = intPow(x, y/2);
[error]       t * t
[error]     } else {
[error]       x * intPow(x, y - 1)
[error]     }
[error]   }
[error] };
[error] 
[error] def intRead() = {
[error]   def aux(accf: (Int, Int) => Int, acc: Int): Int = {
[error]     val c = charRead();
[error]     if (isCharDigit(c)) {
[error]       aux(accf, accf(10 * acc, charDigitToInt(c)))
[error]     } else {
[error]       acc
[error]     }
[error]   };
[error]   val c = charRead();
[error]   if (c == '-') {
[error]     aux((x: Int, y: Int) => x - y, 0)
[error]   } else if (isCharDigit(c)) {
[error]     aux((x: Int, y: Int) => x + y, charDigitToInt(c))
[error]   } else {
[error]     0
[error]   }
[error] };
[error] 
[error] def printInt(i: Int) = {
[error]   if (i < 0) {
[error]     printChar('-')
[error]   };
[error]   def aux(i: Int): Unit = {
[error]     if (i <= -10)
[error]       aux((i + 9) / 10);
[error]     printChar(intCharDigit(-i % 10))
[error]   };
[error]   aux(if (i < 0) i else -i)
[error] };
[error] 
[error] def pairDeriveEq[T,U](eq1: (T, T) => Boolean, eq2: (U, U) => Boolean) =
[error]   (p1: (T, U), p2: (T, U)) => eq1(p1._1, p2._1) && eq2(p1._2, p2._2);
[error] 
[error] def pairDeriveLt[T,U](lt1: (T, T) => Boolean, lt2: (U, U) => Boolean) =
[error]   (p1: (T, U), p2: (T, U)) => lt1(p1._1, p2._1) || (!lt1(p1._1, p2._1) && lt2(p1._2, p2._2));
[error] 
[error] def listMake1[T](e1: T) = e1::Nil;
[error] def listMake2[T](e1: T, e2: T) = e1::listMake1[T](e2);
[error] def listMake3[T](e1: T, e2: T, e3: T) = e1::listMake2[T](e2, e3);
[error] def listMake4[T](e1: T, e2: T, e3: T, e4: T) = e1::listMake3[T](e2, e3, e4);
[error] def listMake5[T](e1: T, e2: T, e3: T, e4: T, e5: T) = e1::listMake4[T](e2, e3, e4, e5);
[error] def listMake6[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T) = e1::listMake5[T](e2, e3, e4, e5, e6);
[error] def listMake7[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T) = e1::listMake6[T](e2, e3, e4, e5, e6, e7);
[error] def listMake8[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T, e8: T) = e1::listMake7[T](e2, e3, e4, e5, e6, e7, e8);
[error] 
[error] def listTabulate[T](n: Int, f: Int => T) = {
[error]   def aux(i: Int, l: List[T]): List[T] = {
[error]     if (i == 0)
[error]       l
[error]     else
[error]       aux(i - 1, f(i - 1)::l)
[error]   };
[error]   aux(n, Nil)
[error] };
[error] 
[error] def listLength[T](l: List[T]): Int =
[error]   if (l.isEmpty)
[error]     0
[error]   else
[error]     1 + listLength[T](l.tail);
[error] 
[error] def listForeach[T](f: T => Unit, l: List[T]): Unit =
[error]   if (!l.isEmpty) {
[error]     f(l.head);
[error]     listForeach[T](f, l.tail)
[error]   };
[error] 
[error] def listMap[T,U](f: T => U, l: List[T]): List[U] =
[error]   if (l.isEmpty)
[error]     Nil
[error]   else
[error]     f(l.head)::listMap[T,U](f, l.tail);
[error] 
[error] def listFoldLeft[T,U](f: (T, U) => T, z: T, l: List[U]): T =
[error]   if (l.isEmpty)
[error]     z
[error]   else
[error]     listFoldLeft[T,U](f, f(z, l.head), l.tail);
[error] 
[error] def listFoldRight[T,U](f: (U, T) => T, z: T, l: List[U]): T =
[error]   if (l.isEmpty)
[error]     z
[error]   else
[error]     f(l.head, listFoldRight[T,U](f, z, l.tail));
[error] 
[error] def listEvery[T](p: T => Boolean, l: List[T]): Boolean =
[error]   l.isEmpty || p(l.head) && listEvery[T](p, l.tail);
[error] 
[error] def listAny[T](p: T => Boolean, l: List[T]): Boolean =
[error]   !l.isEmpty && (p(l.head) || listAny[T](p, l.tail));
[error] 
[error] def listFilter[T](p: T => Boolean, l: List[T]): List[T] =
[error]   listFoldRight[List[T],T]((e: T, r: List[T]) =>  if (p(e)) e::r else r, Nil, l);
[error] 
[error] def listPartition[T](p: T => Boolean, l: List[T]) =
[error]   listFoldRight[(List[T], List[T]),T](
[error]     (e: T,  yn: (List[T], List[T])) =>
[error]       if (p(e))
[error]         (e::yn._1, yn._2)
[error]       else
[error]         (yn._1, e::yn._2),
[error]       (Nil, Nil),
[error]       l);
[error] 
[error] def listTake[T](l: List[T], n: Int): List[T] =
[error]   if (0 == n || l.isEmpty)
[error]     Nil
[error]   else
[error]     l.head :: listTake[T](l.tail, n - 1);
[error] 
[error] def listDrop[T](l: List[T], n: Int): List[T] =
[error]   if (0 == n || l.isEmpty)
[error]     l
[error]   else
[error]     listDrop[T](l.tail, n - 1);
[error] 
[error] def listNth[T](l: List[T], n: Int): T =
[error]   listDrop[T](l, n).head;
[error] 
[error] def listReverse[T](l: List[T]): List[T] =
[error]   listFoldLeft[List[T],T]((t: List[T], h: T) => h::t, Nil, l);
[error] 
[error] def listAppend[T](l1: List[T], l2: List[T]) =
[error]   if (l1.isEmpty) l2
[error]   else if (l2.isEmpty) l1
[error]   else l1.head :: listAppend[T](l1.tail, l2);
[error] 
[error] def listZip[T,U](l1: List[T], l2: List[U]): List[(T, U)] =
[error]   if (l1.isEmpty  || l2.isEmpty)
[error]     Nil
[error]   else
[error]     (l1.head, l2.head) :: listZip[T,U](l1.tail, l2.tail);
[error] 
[error] def printString(s: String) = {
[error]   var idx = 0;
[error]   while (idx < s.length) {
[error]     printChar(s(idx));
[error]     idx = idx + 1
[error]   };
[error]   ()
[error] };
[error] 
[error] def stringConcat(s1: String, s2: String) = {
[error]   val s3 = new Array[Char](s1.length + s2.length);
[error]   var idx = 0;
[error]   while (idx < s1.length) {
[error]     s3(idx) = s1(idx);
[error]     idx = idx + 1
[error]   };
[error]   idx = 0;
[error]   while (idx < s2.length) {
[error]     s3(s1.length + idx) = s2(idx);
[error]     idx = idx + 1
[error]   };
[error]   s3
[error] };
[error] 
[error] // A PCG random number generator. (Specifically, this is the variant
[error] // called XSH RR in the paper, with a 16-bit state and 8-bit output).
[error] // See http://www.pcg-random.org/
[error] 
[error] def makeRNG(seed: Int) = {
[error]   val rng = new Array[Int](1);
[error]   rng(0) = seed & 0xFFFF;
[error]   rng
[error] };
[error] 
[error] def rngGetState(rng: Array[Int]) = rng(0);
[error] 
[error] def rngSetState(rng: Array[Int], state: Int) = rng(0) = state & 0xFFFF;
[error] 
[error] def rngRotateRight8(x: Int, y: Int) =
[error]   ((x >> y) | (x << (8 - y))) & 0xFF;
[error] 
[error] def rngStep(rng: Array[Int]) =
[error]   rngSetState(rng, rngGetState(rng) * 12829 + 47989);
[error] 
[error] def rngOutput(rng: Array[Int]) = {
[error]   val state = rngGetState(rng);
[error]   rngRotateRight8(0xFF & ((state ^ (state >> 5)) >> 5), state >> 13)
[error] };
[error] 
[error] // Return the next 8-bit unsigned integer (0 to 255, included)
[error] def rngNextInt8(rng: Array[Int]) = {
[error]   val i = rngOutput(rng);
[error]   rngStep(rng);
[error]   i
[error] };
[error] 
[error] // FIXME: this is hackish, find a better way to do it (probably using
[error] // multiple streams, see sample/pcg32x2-demo.c in the PCG source).
[error] def rngNextInt(rng: Array[Int]) = {
[error]   val b0 = rngNextInt8(rng);
[error]   val b1 = rngNextInt8(rng);
[error]   val b2 = rngNextInt8(rng);
[error]   val b3 = rngNextInt8(rng);
[error]   (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
[error] };
[error] 
[error] def arrayTabulate[T](n: Int, f: Int => T) = {
[error]   val v = new Array[T](n);
[error]   var i = 0;
[error]   while (i < n) {
[error]     v(i) = f(i);
[error]     i = i + 1
[error]   };
[error]   v
[error] };
[error] 
[error] def arraySwap[T](v: Array[T], i1: Int, i2: Int) = {
[error]   val t = v(i1);
[error]   v(i1) = v(i2);
[error]   v(i2) = t
[error] };
[error] 
[error] def arrayShuffle[T](v: Array[T], seed: Int) = {
[error]   val rng = makeRNG(seed);
[error]   val l = v.length;
[error]   var i = 0;
[error]   while (i < l) {
[error]     val j = i + rngNextInt(rng) % (l - i);
[error]     arraySwap[T](v, i, j);
[error]     i = i + 1
[error]   };
[error]   ()
[error] };
[error] 
[error] def auxArrayPartition[T](v: Array[T], p: T => Boolean, l: Int, h: Int) = {
[error]   def loop(l: Int, h: Int): Int = {
[error]     if (l >= h)
[error]       l
[error]     else if (p(v(l)))
[error]       loop(l + 1, h)
[error]     else if (!p(v(h-1)))
[error]       loop(l, h - 1)
[error]     else {
[error]       arraySwap[T](v, l, h - 1);
[error]       loop(l + 1, h + 1)
[error]     }
[error]   };
[error]   loop(l, h)
[error] };
[error] 
[error] // Reorganize the elements of the vector so that all those not
[error] // satisfying the predicate [p] are before those that satisfy it.
[error] // Return the index of the first element not satisfying [p], or the
[error] // length of the vector if all elements satisfy [p].
[error] def arrayPartition[T](v: Array[T], p: T => Boolean) =
[error]   auxArrayPartition[T](v, p, 0, v.length);
[error] 
[error] def arrayFoldLeft[T,U](f: (T,U) => T, z: T, v: Array[U]) = {
[error]   var i = 0;
[error]   val l = v.length;
[error]   var zz = z;
[error]   while (i < l) {
[error]     zz = f(zz, v(i));
[error]     i = i + 1
[error]   };
[error]   zz
[error] };
[error] 
[error] def arrayForeach[T](f: T => Unit, v: Array[T]) = {
[error]   var i = 0;
[error]   val l = v.length;
[error]   while (i < l) {
[error]     f(v(i));
[error]     i = i + 1
[error]   };
[error]   ()
[error] };
[error] 
[error] def arraySort[T](v: Array[T], el: (T, T) => Boolean) = {
[error]   def qsort(l: Int, h: Int) = {
[error]     if (h - l > 0) {
[error]        val p = v(h);
[error]        val pred = (x: T) => el(x, p);
[error]        val m = auxArrayPartition[T](v, pred, l, h);
[error]        arraySwap[T](v, m, h);
[error]        qsort(l, m - 1);
[error]        qsort(m + 1, h)
[error]     }
[error]   };
[error]   qsort(0, v.length - 1)
[error] };
[error] 
[error] def arrayBinarySearch[T](v: Array[T], e: T, el: (T, T) => Boolean) = {
[error]   def loop(l: Int, h: Int): Int = {
[error]     if (l > h)
[error]       -1 - l
[error]     else {
[error]       val m = l + (h - l) / 2;
[error]       val me = v(m);
[error]       if (el(e, me))
[error]         loop(l, m - 1)
[error]       else if (el(me, e))
[error]         loop(m + 1, h)
[error]       else
[error]         m
[error]     }
[error]   };
[error]   loop(0, v.length - 1)
[error] };
[error] 
[error] def arrayToList[T](v: Array[T]) = {
[error]   def loop(i: Int): List[T] = {
[error]     if (i == -1)
[error]       Nil
[error]     else
[error]       v(i)::loop(i - 1)
[error]   };
[error]   loop(v.length - 1)
[error] };
[error] 
[error] def listToArray[T](l: List[T]) = {
[error]   val n = listLength[T](l);
[error]   val v = new Array[T](n);
[error]   def loop(i: Int, l: List[T]) = {
[error]     if (i < n) {
[error]       v(i) = l.head;
[error]       loop(i + 1, l.tail)
[error]     }
[error]   };
[error]   loop(0, l);
[error]   v
[error] };
[error] 
[error] 
[error] val l = 'O'::'K'::'\n'::Nil;
[error] printChar(l.head);
[error] printChar(l.tail.head);
[error] printChar(l.tail.tail.head)
[error]     
[error] output: 
[error] 
[error] 
[error] 
[error] 
[error] expected output: 
[error] OK
 l
    else {
      val m = l + (h - l) / 2;
      val me = v(m);
      if (el(e, me))
        loop(l, m - 1)
      else if (el(me, e))
        loop(m + 1, h)
      else
        m
    }
  };
  loop(0, v.length - 1)
};

def arrayToList[T](v: Array[T]) = {
  def loop(i: Int): List[T] = {
    if (i == -1)
      Nil
    else
      v(i)::loop(i - 1)
  };
  loop(v.length - 1)
};

def listToArray[T](l: List[T]) = {
  val n = listLength[T](l);
  val v = new Array[T](n);
  def loop(i: Int, l: List[T]) = {
    if (i < n) {
      v(i) = l.head;
      loop(i + 1, l.tail)
    }
  };
  loop(0, l);
  v
};

[info] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists4 started
def printChar(c: Char) = putchar(c.toInt);

def charRead() = getchar().toChar;

def println() = printChar('\n');

val int0 = '0'.toInt;
val int9 = '9'.toInt;
def isCharDigit(c: Char) = {
  val intC = c.toInt;
  int0 <= intC && intC <= int9
};

def charDigitToInt(c: Char) = c.toInt - int0;

def intCharDigit(i: Int) = (i + int0).toChar;

def functionCompose[T,U,V](f: U => V, g: T => U) = (x: T) => f(g(x));

// Integers

def isEven(i: Int) = 0 == (1 & i);

def isOdd(i: Int) = !isEven(i);

def intAbs(i: Int) = if (i < 0) -i else i;

def intSignum(i: Int) = if (i < 0) -1 else { if (i == 0) 0 else 1 };

def intGcd(x: Int, y: Int) = {
    def auxGcd(x: Int, y: Int): Int = {
      if (0 == y)
        x
      else
        auxGcd(y, x % y)
    };
    auxGcd(intAbs(x), intAbs(y))
};

def intPow(x: Int, y: Int): Int = {
  if (y == 0)
    1
  else {
    if (isEven(y)) {
      val t = intPow(x, y/2);
      t * t
    } else {
      x * intPow(x, y - 1)
    }
  }
};

def intRead() = {
  def aux(accf: (Int, Int) => Int, acc: Int): Int = {
    val c = charRead();
    if (isCharDigit(c)) {
      aux(accf, accf(10 * acc, charDigitToInt(c)))
    } else {
      acc
    }
  };
  val c = charRead();
  if (c == '-') {
    aux((x: Int, y: Int) => x - y, 0)
  } else if (isCharDigit(c)) {
    aux((x: Int, y: Int) => x + y, charDigitToInt(c))
  } else {
    0
  }
};

def printInt(i: Int) = {
  if (i < 0) {
    printChar('-')
  };
  def aux(i: Int): Unit = {
    if (i <= -10)
      aux((i + 9) / 10);
    printChar(intCharDigit(-i % 10))
  };
  aux(if (i < 0) i else -i)
};

def pairDeriveEq[T,U](eq1: (T, T) => Boolean, eq2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => eq1(p1._1, p2._1) && eq2(p1._2, p2._2);

def pairDeriveLt[T,U](lt1: (T, T) => Boolean, lt2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => lt1(p1._1, p2._1) || (!lt1(p1._1, p2._1) && lt2(p1._2, p2._2));

def listMake1[T](e1: T) = e1::Nil;
def listMake2[T](e1: T, e2: T) = e1::listMake1[T](e2);
def listMake3[T](e1: T, e2: T, e3: T) = e1::listMake2[T](e2, e3);
def listMake4[T](e1: T, e2: T, e3: T, e4: T) = e1::listMake3[T](e2, e3, e4);
def listMake5[T](e1: T, e2: T, e3: T, e4: T, e5: T) = e1::listMake4[T](e2, e3, e4, e5);
def listMake6[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T) = e1::listMake5[T](e2, e3, e4, e5, e6);
def listMake7[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T) = e1::listMake6[T](e2, e3, e4, e5, e6, e7);
def listMake8[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T, e8: T) = e1::listMake7[T](e2, e3, e4, e5, e6, e7, e8);

def listTabulate[T](n: Int, f: Int => T) = {
  def aux(i: Int, l: List[T]): List[T] = {
    if (i == 0)
      l
    else
      aux(i - 1, f(i - 1)::l)
  };
  aux(n, Nil)
};

def listLength[T](l: List[T]): Int =
  if (l.isEmpty)
    0
  else
    1 + listLength[T](l.tail);

def listForeach[T](f: T => Unit, l: List[T]): Unit =
  if (!l.isEmpty) {
    f(l.head);
    listForeach[T](f, l.tail)
  };

def listMap[T,U](f: T => U, l: List[T]): List[U] =
  if (l.isEmpty)
    Nil
  else
    f(l.head)::listMap[T,U](f, l.tail);

def listFoldLeft[T,U](f: (T, U) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    listFoldLeft[T,U](f, f(z, l.head), l.tail);

def listFoldRight[T,U](f: (U, T) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    f(l.head, listFoldRight[T,U](f, z, l.tail));

def listEvery[T](p: T => Boolean, l: List[T]): Boolean =
  l.isEmpty || p(l.head) && listEvery[T](p, l.tail);

def listAny[T](p: T => Boolean, l: List[T]): Boolean =
  !l.isEmpty && (p(l.head) || listAny[T](p, l.tail));

def listFilter[T](p: T => Boolean, l: List[T]): List[T] =
  listFoldRight[List[T],T]((e: T, r: List[T]) =>  if (p(e)) e::r else r, Nil, l);

def listPartition[T](p: T => Boolean, l: List[T]) =
  listFoldRight[(List[T], List[T]),T](
    (e: T,  yn: (List[T], List[T])) =>
      if (p(e))
        (e::yn._1, yn._2)
      else
        (yn._1, e::yn._2),
      (Nil, Nil),
      l);

def listTake[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    Nil
  else
    l.head :: listTake[T](l.tail, n - 1);

def listDrop[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    l
  else
    listDrop[T](l.tail, n - 1);

def listNth[T](l: List[T], n: Int): T =
  listDrop[T](l, n).head;

def listReverse[T](l: List[T]): List[T] =
  listFoldLeft[List[T],T]((t: List[T], h: T) => h::t, Nil, l);

def listAppend[T](l1: List[T], l2: List[T]) =
  if (l1.isEmpty) l2
  else if (l2.isEmpty) l1
  else l1.head :: listAppend[T](l1.tail, l2);

def listZip[T,U](l1: List[T], l2: List[U]): List[(T, U)] =
  if (l1.isEmpty  || l2.isEmpty)
    Nil
  else
    (l1.head, l2.head) :: listZip[T,U](l1.tail, l2.tail);

def printString(s: String) = {
  var idx = 0;
  while (idx < s.length) {
    printChar(s(idx));
    idx = idx + 1
  };
  ()
};

def stringConcat(s1: String, s2: String) = {
  val s3 = new Array[Char](s1.length + s2.length);
  var idx = 0;
  while (idx < s1.length) {
    s3(idx) = s1(idx);
    idx = idx + 1
  };
  idx = 0;
  while (idx < s2.length) {
    s3(s1.length + idx) = s2(idx);
    idx = idx + 1
  };
  s3
};

// A PCG random number generator. (Specifically, this is the variant
// called XSH RR in the paper, with a 16-bit state and 8-bit output).
// See http://www.pcg-random.org/

def makeRNG(seed: Int) = {
  val rng = new Array[Int](1);
  rng(0) = seed & 0xFFFF;
  rng
};

def rngGetState(rng: Array[Int]) = rng(0);

def rngSetState(rng: Array[Int], state: Int) = rng(0) = state & 0xFFFF;

def rngRotateRight8(x: Int, y: Int) =
  ((x >> y) | (x << (8 - y))) & 0xFF;

def rngStep(rng: Array[Int]) =
  rngSetState(rng, rngGetState(rng) * 12829 + 47989);

def rngOutput(rng: Array[Int]) = {
  val state = rngGetState(rng);
  rngRotateRight8(0xFF & ((state ^ (state >> 5)) >> 5), state >> 13)
};

// Return the next 8-bit unsigned integer (0 to 255, included)
def rngNextInt8(rng: Array[Int]) = {
  val i = rngOutput(rng);
  rngStep(rng);
  i
};

// FIXME: this is hackish, find a better way to do it (probably using
// multiple streams, see sample/pcg32x2-demo.c in the PCG source).
def rngNextInt(rng: Array[Int]) = {
  val b0 = rngNextInt8(rng);
  val b1 = rngNextInt8(rng);
  val b2 = rngNextInt8(rng);
  val b3 = rngNextInt8(rng);
  (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
};

def arrayTabulate[T](n: Int, f: Int => T) = {
  val v = new Array[T](n);
  var i = 0;
  while (i < n) {
    v(i) = f(i);
    i = i + 1
  };
  v
};

def arraySwap[T](v: Array[T], i1: Int, i2: Int) = {
  val t = v(i1);
  v(i1) = v(i2);
  v(i2) = t
};

def arrayShuffle[T](v: Array[T], seed: Int) = {
  val rng = makeRNG(seed);
  val l = v.length;
  var i = 0;
  while (i < l) {
    val j = i + rngNextInt(rng) % (l - i);
    arraySwap[T](v, i, j);
    i = i + 1
  };
  ()
};

def auxArrayPartition[T](v: Array[T], p: T => Boolean, l: Int, h: Int) = {
  def loop(l: Int, h: Int): Int = {
    if (l >= h)
      l
    else if (p(v(l)))
      loop(l + 1, h)
    else if (!p(v(h-1)))
      loop(l, h - 1)
    else {
      arraySwap[T](v, l, h - 1);
      loop(l + 1, h + 1)
    }
  };
  loop(l, h)
};

// Reorganize the elements of the vector so that all those not
// satisfying the predicate [p] are before those that satisfy it.
// Return the index of the first element not satisfying [p], or the
// length of the vector if all elements satisfy [p].
def arrayPartition[T](v: Array[T], p: T => Boolean) =
  auxArrayPartition[T](v, p, 0, v.length);

def arrayFoldLeft[T,U](f: (T,U) => T, z: T, v: Array[U]) = {
  var i = 0;
  val l = v.length;
  var zz = z;
  while (i < l) {
    zz = f(zz, v(i));
    i = i + 1
  };
  zz
};

def arrayForeach[T](f: T => Unit, v: Array[T]) = {
  var i = 0;
  val l = v.length;
  while (i < l) {
    f(v(i));
    i = i + 1
  };
  ()
};

def arraySort[T](v: Array[T], el: (T, T) => Boolean) = {
  def qsort(l: Int, h: Int) = {
    if (h - l > 0) {
       val p = v(h);
       val pred = (x: T) => el(x, p);
       val m = auxArrayPartition[T](v, pred, l, h);
       arraySwap[T](v, m, h);
       qsort(l, m - 1);
       qsort(m + 1, h)
    }
  };
  qsort(0, v.length - 1)
};

def arrayBinarySearch[T](v: Array[T], e: T, el: (T, T) => Boolean) = {
  def loop(l: Int, h: Int): Int = {
    if (l > h)
      -1 -[error] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists4 failed: key not found: listMake2
 l
    else {
      val m = l + (h - l) / 2;
      val me = v(m);
      if (el(e, me))
        loop(l, m - 1)
      else if (el(me, e))
        loop(m + 1, h)
      else
        m
    }
  };
  loop(0, v.length - 1)
};

def arrayToList[T](v: Array[T]) = {
  def loop(i: Int): List[T] = {
    if (i == -1)
      Nil
    else
      v(i)::loop(i - 1)
  };
  loop(v.length - 1)
};

def listToArray[T](l: List[T]) = {
  val n = listLength[T](l);
  val v = new Array[T](n);
  def loop(i: Int, l: List[T]) = {
    if (i < n) {
      v(i) = l.head;
      loop(i + 1, l.tail)
    }
  };
  loop(0, l);
  v
};

[error]     at scala.collection.MapLike$class.default(MapLike.scala:228)
[error]     at scala.collection.AbstractMap.default(Map.scala:59)
[error]     at scala.collection.MapLike$class.apply(MapLike.scala:141)
[error]     at scala.collection.AbstractMap.apply(Map.scala:59)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.foreach(List.scala:381)
[error]     at scala.collection.TraversableLike$class.map(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.map(List.scala:285)
[error]     at miniscala.CPSInterpreter.eval(CPSInterpreter.scala:40)
[error]     at miniscala.CPSInterpreter.apply(CPSInterpreter.scala:18)
[error]     at miniscala.CPSInterpreterLow.apply(CPSInterpreter.scala:176)
[error]     at scala.Function1$$anonfun$andThen$1.apply(Function1.scala:52)
[error]     at miniscala.test.infrastructure.CompilerTest$class.miniscala$test$infrastructure$CompilerTest$$compileInner(CompilerTest.scala:37)
[error]     at miniscala.test.infrastructure.CompilerTest$$anonfun$compileUsingPipelineAndRedirect$1.apply(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.SandboxedTest$$anon$1.run(SandboxedTest.scala:24)
[error]     at java.security.AccessController.doPrivileged(Native Method)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTest(SandboxedTest.scala:34)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTestWithRedirectedIO(SandboxedTest.scala:45)
[error]     at miniscala.test.infrastructure.CompilerTest$class.compileUsingPipelineAndRedirect(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.CPSTest.compileUsingPipelineAndRedirect(CPSTest.scala:11)
[error]     at miniscala.test.infrastructure.CPSOptTest.testCPSLowProgramOutput(CPSOptTest.scala:91)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$class.testLibLists4(LibraryOKTests.scala:52)
[error]     at miniscala.test.CPSOptimizer_Blackbox.testLibLists4(CPSOptimizer_Blackbox.scala:7)
[error]     ...
[info] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists3 started
def printChar(c: Char) = putchar(c.toInt);

def charRead() = getchar().toChar;

def println() = printChar('\n');

val int0 = '0'.toInt;
val int9 = '9'.toInt;
def isCharDigit(c: Char) = {
  val intC = c.toInt;
  int0 <= intC && intC <= int9
};

def charDigitToInt(c: Char) = c.toInt - int0;

def intCharDigit(i: Int) = (i + int0).toChar;

def functionCompose[T,U,V](f: U => V, g: T => U) = (x: T) => f(g(x));

// Integers

def isEven(i: Int) = 0 == (1 & i);

def isOdd(i: Int) = !isEven(i);

def intAbs(i: Int) = if (i < 0) -i else i;

def intSignum(i: Int) = if (i < 0) -1 else { if (i == 0) 0 else 1 };

def intGcd(x: Int, y: Int) = {
    def auxGcd(x: Int, y: Int): Int = {
      if (0 == y)
        x
      else
        auxGcd(y, x % y)
    };
    auxGcd(intAbs(x), intAbs(y))
};

def intPow(x: Int, y: Int): Int = {
  if (y == 0)
    1
  else {
    if (isEven(y)) {
      val t = intPow(x, y/2);
      t * t
    } else {
      x * intPow(x, y - 1)
    }
  }
};

def intRead() = {
  def aux(accf: (Int, Int) => Int, acc: Int): Int = {
    val c = charRead();
    if (isCharDigit(c)) {
      aux(accf, accf(10 * acc, charDigitToInt(c)))
    } else {
      acc
    }
  };
  val c = charRead();
  if (c == '-') {
    aux((x: Int, y: Int) => x - y, 0)
  } else if (isCharDigit(c)) {
    aux((x: Int, y: Int) => x + y, charDigitToInt(c))
  } else {
    0
  }
};

def printInt(i: Int) = {
  if (i < 0) {
    printChar('-')
  };
  def aux(i: Int): Unit = {
    if (i <= -10)
      aux((i + 9) / 10);
    printChar(intCharDigit(-i % 10))
  };
  aux(if (i < 0) i else -i)
};

def pairDeriveEq[T,U](eq1: (T, T) => Boolean, eq2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => eq1(p1._1, p2._1) && eq2(p1._2, p2._2);

def pairDeriveLt[T,U](lt1: (T, T) => Boolean, lt2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => lt1(p1._1, p2._1) || (!lt1(p1._1, p2._1) && lt2(p1._2, p2._2));

def listMake1[T](e1: T) = e1::Nil;
def listMake2[T](e1: T, e2: T) = e1::listMake1[T](e2);
def listMake3[T](e1: T, e2: T, e3: T) = e1::listMake2[T](e2, e3);
def listMake4[T](e1: T, e2: T, e3: T, e4: T) = e1::listMake3[T](e2, e3, e4);
def listMake5[T](e1: T, e2: T, e3: T, e4: T, e5: T) = e1::listMake4[T](e2, e3, e4, e5);
def listMake6[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T) = e1::listMake5[T](e2, e3, e4, e5, e6);
def listMake7[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T) = e1::listMake6[T](e2, e3, e4, e5, e6, e7);
def listMake8[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T, e8: T) = e1::listMake7[T](e2, e3, e4, e5, e6, e7, e8);

def listTabulate[T](n: Int, f: Int => T) = {
  def aux(i: Int, l: List[T]): List[T] = {
    if (i == 0)
      l
    else
      aux(i - 1, f(i - 1)::l)
  };
  aux(n, Nil)
};

def listLength[T](l: List[T]): Int =
  if (l.isEmpty)
    0
  else
    1 + listLength[T](l.tail);

def listForeach[T](f: T => Unit, l: List[T]): Unit =
  if (!l.isEmpty) {
    f(l.head);
    listForeach[T](f, l.tail)
  };

def listMap[T,U](f: T => U, l: List[T]): List[U] =
  if (l.isEmpty)
    Nil
  else
    f(l.head)::listMap[T,U](f, l.tail);

def listFoldLeft[T,U](f: (T, U) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    listFoldLeft[T,U](f, f(z, l.head), l.tail);

def listFoldRight[T,U](f: (U, T) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    f(l.head, listFoldRight[T,U](f, z, l.tail));

def listEvery[T](p: T => Boolean, l: List[T]): Boolean =
  l.isEmpty || p(l.head) && listEvery[T](p, l.tail);

def listAny[T](p: T => Boolean, l: List[T]): Boolean =
  !l.isEmpty && (p(l.head) || listAny[T](p, l.tail));

def listFilter[T](p: T => Boolean, l: List[T]): List[T] =
  listFoldRight[List[T],T]((e: T, r: List[T]) =>  if (p(e)) e::r else r, Nil, l);

def listPartition[T](p: T => Boolean, l: List[T]) =
  listFoldRight[(List[T], List[T]),T](
    (e: T,  yn: (List[T], List[T])) =>
      if (p(e))
        (e::yn._1, yn._2)
      else
        (yn._1, e::yn._2),
      (Nil, Nil),
      l);

def listTake[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    Nil
  else
    l.head :: listTake[T](l.tail, n - 1);

def listDrop[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    l
  else
    listDrop[T](l.tail, n - 1);

def listNth[T](l: List[T], n: Int): T =
  listDrop[T](l, n).head;

def listReverse[T](l: List[T]): List[T] =
  listFoldLeft[List[T],T]((t: List[T], h: T) => h::t, Nil, l);

def listAppend[T](l1: List[T], l2: List[T]) =
  if (l1.isEmpty) l2
  else if (l2.isEmpty) l1
  else l1.head :: listAppend[T](l1.tail, l2);

def listZip[T,U](l1: List[T], l2: List[U]): List[(T, U)] =
  if (l1.isEmpty  || l2.isEmpty)
    Nil
  else
    (l1.head, l2.head) :: listZip[T,U](l1.tail, l2.tail);

def printString(s: String) = {
  var idx = 0;
  while (idx < s.length) {
    printChar(s(idx));
    idx = idx + 1
  };
  ()
};

def stringConcat(s1: String, s2: String) = {
  val s3 = new Array[Char](s1.length + s2.length);
  var idx = 0;
  while (idx < s1.length) {
    s3(idx) = s1(idx);
    idx = idx + 1
  };
  idx = 0;
  while (idx < s2.length) {
    s3(s1.length + idx) = s2(idx);
    idx = idx + 1
  };
  s3
};

// A PCG random number generator. (Specifically, this is the variant
// called XSH RR in the paper, with a 16-bit state and 8-bit output).
// See http://www.pcg-random.org/

def makeRNG(seed: Int) = {
  val rng = new Array[Int](1);
  rng(0) = seed & 0xFFFF;
  rng
};

def rngGetState(rng: Array[Int]) = rng(0);

def rngSetState(rng: Array[Int], state: Int) = rng(0) = state & 0xFFFF;

def rngRotateRight8(x: Int, y: Int) =
  ((x >> y) | (x << (8 - y))) & 0xFF;

def rngStep(rng: Array[Int]) =
  rngSetState(rng, rngGetState(rng) * 12829 + 47989);

def rngOutput(rng: Array[Int]) = {
  val state = rngGetState(rng);
  rngRotateRight8(0xFF & ((state ^ (state >> 5)) >> 5), state >> 13)
};

// Return the next 8-bit unsigned integer (0 to 255, included)
def rngNextInt8(rng: Array[Int]) = {
  val i = rngOutput(rng);
  rngStep(rng);
  i
};

// FIXME: this is hackish, find a better way to do it (probably using
// multiple streams, see sample/pcg32x2-demo.c in the PCG source).
def rngNextInt(rng: Array[Int]) = {
  val b0 = rngNextInt8(rng);
  val b1 = rngNextInt8(rng);
  val b2 = rngNextInt8(rng);
  val b3 = rngNextInt8(rng);
  (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
};

def arrayTabulate[T](n: Int, f: Int => T) = {
  val v = new Array[T](n);
  var i = 0;
  while (i < n) {
    v(i) = f(i);
    i = i + 1
  };
  v
};

def arraySwap[T](v: Array[T], i1: Int, i2: Int) = {
  val t = v(i1);
  v(i1) = v(i2);
  v(i2) = t
};

def arrayShuffle[T](v: Array[T], seed: Int) = {
  val rng = makeRNG(seed);
  val l = v.length;
  var i = 0;
  while (i < l) {
    val j = i + rngNextInt(rng) % (l - i);
    arraySwap[T](v, i, j);
    i = i + 1
  };
  ()
};

def auxArrayPartition[T](v: Array[T], p: T => Boolean, l: Int, h: Int) = {
  def loop(l: Int, h: Int): Int = {
    if (l >= h)
      l
    else if (p(v(l)))
      loop(l + 1, h)
    else if (!p(v(h-1)))
      loop(l, h - 1)
    else {
      arraySwap[T](v, l, h - 1);
      loop(l + 1, h + 1)
    }
  };
  loop(l, h)
};

// Reorganize the elements of the vector so that all those not
// satisfying the predicate [p] are before those that satisfy it.
// Return the index of the first element not satisfying [p], or the
// length of the vector if all elements satisfy [p].
def arrayPartition[T](v: Array[T], p: T => Boolean) =
  auxArrayPartition[T](v, p, 0, v.length);

def arrayFoldLeft[T,U](f: (T,U) => T, z: T, v: Array[U]) = {
  var i = 0;
  val l = v.length;
  var zz = z;
  while (i < l) {
    zz = f(zz, v(i));
    i = i + 1
  };
  zz
};

def arrayForeach[T](f: T => Unit, v: Array[T]) = {
  var i = 0;
  val l = v.length;
  while (i < l) {
    f(v(i));
    i = i + 1
  };
  ()
};

def arraySort[T](v: Array[T], el: (T, T) => Boolean) = {
  def qsort(l: Int, h: Int) = {
    if (h - l > 0) {
       val p = v(h);
       val pred = (x: T) => el(x, p);
       val m = auxArrayPartition[T](v, pred, l, h);
       arraySwap[T](v, m, h);
       qsort(l, m - 1);
       qsort(m + 1, h)
    }
  };
  qsort(0, v.length - 1)
};

def arrayBinarySearch[T](v: Array[T], e: T, el: (T, T) => Boolean) = {
  def loop(l: Int, h: Int): Int = {
    if (l > h)
      -1 -[error] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists3 failed: key not found: listMake2
 l
    else {
      val m = l + (h - l) / 2;
      val me = v(m);
      if (el(e, me))
        loop(l, m - 1)
      else if (el(me, e))
        loop(m + 1, h)
      else
        m
    }
  };
  loop(0, v.length - 1)
};

def arrayToList[T](v: Array[T]) = {
  def loop(i: Int): List[T] = {
    if (i == -1)
      Nil
    else
      v(i)::loop(i - 1)
  };
  loop(v.length - 1)
};

def listToArray[T](l: List[T]) = {
  val n = listLength[T](l);
  val v = new Array[T](n);
  def loop(i: Int, l: List[T]) = {
    if (i < n) {
      v(i) = l.head;
      loop(i + 1, l.tail)
    }
  };
  loop(0, l);
  v
};

[error]     at scala.collection.MapLike$class.default(MapLike.scala:228)
[error]     at scala.collection.AbstractMap.default(Map.scala:59)
[error]     at scala.collection.MapLike$class.apply(MapLike.scala:141)
[error]     at scala.collection.AbstractMap.apply(Map.scala:59)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.foreach(List.scala:381)
[error]     at scala.collection.TraversableLike$class.map(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.map(List.scala:285)
[error]     at miniscala.CPSInterpreter.eval(CPSInterpreter.scala:40)
[error]     at miniscala.CPSInterpreter.apply(CPSInterpreter.scala:18)
[error]     at miniscala.CPSInterpreterLow.apply(CPSInterpreter.scala:176)
[error]     at scala.Function1$$anonfun$andThen$1.apply(Function1.scala:52)
[error]     at miniscala.test.infrastructure.CompilerTest$class.miniscala$test$infrastructure$CompilerTest$$compileInner(CompilerTest.scala:37)
[error]     at miniscala.test.infrastructure.CompilerTest$$anonfun$compileUsingPipelineAndRedirect$1.apply(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.SandboxedTest$$anon$1.run(SandboxedTest.scala:24)
[error]     at java.security.AccessController.doPrivileged(Native Method)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTest(SandboxedTest.scala:34)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTestWithRedirectedIO(SandboxedTest.scala:45)
[error]     at miniscala.test.infrastructure.CompilerTest$class.compileUsingPipelineAndRedirect(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.CPSTest.compileUsingPipelineAndRedirect(CPSTest.scala:11)
[error]     at miniscala.test.infrastructure.CPSOptTest.testCPSLowProgramOutput(CPSOptTest.scala:91)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$class.testLibLists3(LibraryOKTests.scala:46)
[error]     at miniscala.test.CPSOptimizer_Blackbox.testLibLists3(CPSOptimizer_Blackbox.scala:7)
[error]     ...
[info] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists8 started
def printChar(c: Char) = putchar(c.toInt);

def charRead() = getchar().toChar;

def println() = printChar('\n');

val int0 = '0'.toInt;
val int9 = '9'.toInt;
def isCharDigit(c: Char) = {
  val intC = c.toInt;
  int0 <= intC && intC <= int9
};

def charDigitToInt(c: Char) = c.toInt - int0;

def intCharDigit(i: Int) = (i + int0).toChar;

def functionCompose[T,U,V](f: U => V, g: T => U) = (x: T) => f(g(x));

// Integers

def isEven(i: Int) = 0 == (1 & i);

def isOdd(i: Int) = !isEven(i);

def intAbs(i: Int) = if (i < 0) -i else i;

def intSignum(i: Int) = if (i < 0) -1 else { if (i == 0) 0 else 1 };

def intGcd(x: Int, y: Int) = {
    def auxGcd(x: Int, y: Int): Int = {
      if (0 == y)
        x
      else
        auxGcd(y, x % y)
    };
    auxGcd(intAbs(x), intAbs(y))
};

def intPow(x: Int, y: Int): Int = {
  if (y == 0)
    1
  else {
    if (isEven(y)) {
      val t = intPow(x, y/2);
      t * t
    } else {
      x * intPow(x, y - 1)
    }
  }
};

def intRead() = {
  def aux(accf: (Int, Int) => Int, acc: Int): Int = {
    val c = charRead();
    if (isCharDigit(c)) {
      aux(accf, accf(10 * acc, charDigitToInt(c)))
    } else {
      acc
    }
  };
  val c = charRead();
  if (c == '-') {
    aux((x: Int, y: Int) => x - y, 0)
  } else if (isCharDigit(c)) {
    aux((x: Int, y: Int) => x + y, charDigitToInt(c))
  } else {
    0
  }
};

def printInt(i: Int) = {
  if (i < 0) {
    printChar('-')
  };
  def aux(i: Int): Unit = {
    if (i <= -10)
      aux((i + 9) / 10);
    printChar(intCharDigit(-i % 10))
  };
  aux(if (i < 0) i else -i)
};

def pairDeriveEq[T,U](eq1: (T, T) => Boolean, eq2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => eq1(p1._1, p2._1) && eq2(p1._2, p2._2);

def pairDeriveLt[T,U](lt1: (T, T) => Boolean, lt2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => lt1(p1._1, p2._1) || (!lt1(p1._1, p2._1) && lt2(p1._2, p2._2));

def listMake1[T](e1: T) = e1::Nil;
def listMake2[T](e1: T, e2: T) = e1::listMake1[T](e2);
def listMake3[T](e1: T, e2: T, e3: T) = e1::listMake2[T](e2, e3);
def listMake4[T](e1: T, e2: T, e3: T, e4: T) = e1::listMake3[T](e2, e3, e4);
def listMake5[T](e1: T, e2: T, e3: T, e4: T, e5: T) = e1::listMake4[T](e2, e3, e4, e5);
def listMake6[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T) = e1::listMake5[T](e2, e3, e4, e5, e6);
def listMake7[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T) = e1::listMake6[T](e2, e3, e4, e5, e6, e7);
def listMake8[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T, e8: T) = e1::listMake7[T](e2, e3, e4, e5, e6, e7, e8);

def listTabulate[T](n: Int, f: Int => T) = {
  def aux(i: Int, l: List[T]): List[T] = {
    if (i == 0)
      l
    else
      aux(i - 1, f(i - 1)::l)
  };
  aux(n, Nil)
};

def listLength[T](l: List[T]): Int =
  if (l.isEmpty)
    0
  else
    1 + listLength[T](l.tail);

def listForeach[T](f: T => Unit, l: List[T]): Unit =
  if (!l.isEmpty) {
    f(l.head);
    listForeach[T](f, l.tail)
  };

def listMap[T,U](f: T => U, l: List[T]): List[U] =
  if (l.isEmpty)
    Nil
  else
    f(l.head)::listMap[T,U](f, l.tail);

def listFoldLeft[T,U](f: (T, U) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    listFoldLeft[T,U](f, f(z, l.head), l.tail);

def listFoldRight[T,U](f: (U, T) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    f(l.head, listFoldRight[T,U](f, z, l.tail));

def listEvery[T](p: T => Boolean, l: List[T]): Boolean =
  l.isEmpty || p(l.head) && listEvery[T](p, l.tail);

def listAny[T](p: T => Boolean, l: List[T]): Boolean =
  !l.isEmpty && (p(l.head) || listAny[T](p, l.tail));

def listFilter[T](p: T => Boolean, l: List[T]): List[T] =
  listFoldRight[List[T],T]((e: T, r: List[T]) =>  if (p(e)) e::r else r, Nil, l);

def listPartition[T](p: T => Boolean, l: List[T]) =
  listFoldRight[(List[T], List[T]),T](
    (e: T,  yn: (List[T], List[T])) =>
      if (p(e))
        (e::yn._1, yn._2)
      else
        (yn._1, e::yn._2),
      (Nil, Nil),
      l);

def listTake[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    Nil
  else
    l.head :: listTake[T](l.tail, n - 1);

def listDrop[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    l
  else
    listDrop[T](l.tail, n - 1);

def listNth[T](l: List[T], n: Int): T =
  listDrop[T](l, n).head;

def listReverse[T](l: List[T]): List[T] =
  listFoldLeft[List[T],T]((t: List[T], h: T) => h::t, Nil, l);

def listAppend[T](l1: List[T], l2: List[T]) =
  if (l1.isEmpty) l2
  else if (l2.isEmpty) l1
  else l1.head :: listAppend[T](l1.tail, l2);

def listZip[T,U](l1: List[T], l2: List[U]): List[(T, U)] =
  if (l1.isEmpty  || l2.isEmpty)
    Nil
  else
    (l1.head, l2.head) :: listZip[T,U](l1.tail, l2.tail);

def printString(s: String) = {
  var idx = 0;
  while (idx < s.length) {
    printChar(s(idx));
    idx = idx + 1
  };
  ()
};

def stringConcat(s1: String, s2: String) = {
  val s3 = new Array[Char](s1.length + s2.length);
  var idx = 0;
  while (idx < s1.length) {
    s3(idx) = s1(idx);
    idx = idx + 1
  };
  idx = 0;
  while (idx < s2.length) {
    s3(s1.length + idx) = s2(idx);
    idx = idx + 1
  };
  s3
};

// A PCG random number generator. (Specifically, this is the variant
// called XSH RR in the paper, with a 16-bit state and 8-bit output).
// See http://www.pcg-random.org/

def makeRNG(seed: Int) = {
  val rng = new Array[Int](1);
  rng(0) = seed & 0xFFFF;
  rng
};

def rngGetState(rng: Array[Int]) = rng(0);

def rngSetState(rng: Array[Int], state: Int) = rng(0) = state & 0xFFFF;

def rngRotateRight8(x: Int, y: Int) =
  ((x >> y) | (x << (8 - y))) & 0xFF;

def rngStep(rng: Array[Int]) =
  rngSetState(rng, rngGetState(rng) * 12829 + 47989);

def rngOutput(rng: Array[Int]) = {
  val state = rngGetState(rng);
  rngRotateRight8(0xFF & ((state ^ (state >> 5)) >> 5), state >> 13)
};

// Return the next 8-bit unsigned integer (0 to 255, included)
def rngNextInt8(rng: Array[Int]) = {
  val i = rngOutput(rng);
  rngStep(rng);
  i
};

// FIXME: this is hackish, find a better way to do it (probably using
// multiple streams, see sample/pcg32x2-demo.c in the PCG source).
def rngNextInt(rng: Array[Int]) = {
  val b0 = rngNextInt8(rng);
  val b1 = rngNextInt8(rng);
  val b2 = rngNextInt8(rng);
  val b3 = rngNextInt8(rng);
  (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
};

def arrayTabulate[T](n: Int, f: Int => T) = {
  val v = new Array[T](n);
  var i = 0;
  while (i < n) {
    v(i) = f(i);
    i = i + 1
  };
  v
};

def arraySwap[T](v: Array[T], i1: Int, i2: Int) = {
  val t = v(i1);
  v(i1) = v(i2);
  v(i2) = t
};

def arrayShuffle[T](v: Array[T], seed: Int) = {
  val rng = makeRNG(seed);
  val l = v.length;
  var i = 0;
  while (i < l) {
    val j = i + rngNextInt(rng) % (l - i);
    arraySwap[T](v, i, j);
    i = i + 1
  };
  ()
};

def auxArrayPartition[T](v: Array[T], p: T => Boolean, l: Int, h: Int) = {
  def loop(l: Int, h: Int): Int = {
    if (l >= h)
      l
    else if (p(v(l)))
      loop(l + 1, h)
    else if (!p(v(h-1)))
      loop(l, h - 1)
    else {
      arraySwap[T](v, l, h - 1);
      loop(l + 1, h + 1)
    }
  };
  loop(l, h)
};

// Reorganize the elements of the vector so that all those not
// satisfying the predicate [p] are before those that satisfy it.
// Return the index of the first element not satisfying [p], or the
// length of the vector if all elements satisfy [p].
def arrayPartition[T](v: Array[T], p: T => Boolean) =
  auxArrayPartition[T](v, p, 0, v.length);

def arrayFoldLeft[T,U](f: (T,U) => T, z: T, v: Array[U]) = {
  var i = 0;
  val l = v.length;
  var zz = z;
  while (i < l) {
    zz = f(zz, v(i));
    i = i + 1
  };
  zz
};

def arrayForeach[T](f: T => Unit, v: Array[T]) = {
  var i = 0;
  val l = v.length;
  while (i < l) {
    f(v(i));
    i = i + 1
  };
  ()
};

def arraySort[T](v: Array[T], el: (T, T) => Boolean) = {
  def qsort(l: Int, h: Int) = {
    if (h - l > 0) {
       val p = v(h);
       val pred = (x: T) => el(x, p);
       val m = auxArrayPartition[T](v, pred, l, h);
       arraySwap[T](v, m, h);
       qsort(l, m - 1);
       qsort(m + 1, h)
    }
  };
  qsort(0, v.length - 1)
};

def arrayBinarySearch[T](v: Array[T], e: T, el: (T, T) => Boolean) = {
  def loop(l: Int, h: Int): Int = {
    if (l > h)
      -1 -[error] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists8 failed: key not found: listMake2
 l
    else {
      val m = l + (h - l) / 2;
      val me = v(m);
      if (el(e, me))
        loop(l, m - 1)
      else if (el(me, e))
        loop(m + 1, h)
      else
        m
    }
  };
  loop(0, v.length - 1)
};

def arrayToList[T](v: Array[T]) = {
  def loop(i: Int): List[T] = {
    if (i == -1)
      Nil
    else
      v(i)::loop(i - 1)
  };
  loop(v.length - 1)
};

def listToArray[T](l: List[T]) = {
  val n = listLength[T](l);
  val v = new Array[T](n);
  def loop(i: Int, l: List[T]) = {
    if (i < n) {
      v(i) = l.head;
      loop(i + 1, l.tail)
    }
  };
  loop(0, l);
  v
};

[error]     at scala.collection.MapLike$class.default(MapLike.scala:228)
[error]     at scala.collection.AbstractMap.default(Map.scala:59)
[error]     at scala.collection.MapLike$class.apply(MapLike.scala:141)
[error]     at scala.collection.AbstractMap.apply(Map.scala:59)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.foreach(List.scala:381)
[error]     at scala.collection.TraversableLike$class.map(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.map(List.scala:285)
[error]     at miniscala.CPSInterpreter.eval(CPSInterpreter.scala:40)
[error]     at miniscala.CPSInterpreter.apply(CPSInterpreter.scala:18)
[error]     at miniscala.CPSInterpreterLow.apply(CPSInterpreter.scala:176)
[error]     at scala.Function1$$anonfun$andThen$1.apply(Function1.scala:52)
[error]     at miniscala.test.infrastructure.CompilerTest$class.miniscala$test$infrastructure$CompilerTest$$compileInner(CompilerTest.scala:37)
[error]     at miniscala.test.infrastructure.CompilerTest$$anonfun$compileUsingPipelineAndRedirect$1.apply(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.SandboxedTest$$anon$1.run(SandboxedTest.scala:24)
[error]     at java.security.AccessController.doPrivileged(Native Method)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTest(SandboxedTest.scala:34)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTestWithRedirectedIO(SandboxedTest.scala:45)
[error]     at miniscala.test.infrastructure.CompilerTest$class.compileUsingPipelineAndRedirect(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.CPSTest.compileUsingPipelineAndRedirect(CPSTest.scala:11)
[error]     at miniscala.test.infrastructure.CPSOptTest.testCPSLowProgramOutput(CPSOptTest.scala:91)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$class.testLibLists8(LibraryOKTests.scala:90)
[error]     at miniscala.test.CPSOptimizer_Blackbox.testLibLists8(CPSOptimizer_Blackbox.scala:7)
[error]     ...
[info] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists9 started
def printChar(c: Char) = putchar(c.toInt);

def charRead() = getchar().toChar;

def println() = printChar('\n');

val int0 = '0'.toInt;
val int9 = '9'.toInt;
def isCharDigit(c: Char) = {
  val intC = c.toInt;
  int0 <= intC && intC <= int9
};

def charDigitToInt(c: Char) = c.toInt - int0;

def intCharDigit(i: Int) = (i + int0).toChar;

def functionCompose[T,U,V](f: U => V, g: T => U) = (x: T) => f(g(x));

// Integers

def isEven(i: Int) = 0 == (1 & i);

def isOdd(i: Int) = !isEven(i);

def intAbs(i: Int) = if (i < 0) -i else i;

def intSignum(i: Int) = if (i < 0) -1 else { if (i == 0) 0 else 1 };

def intGcd(x: Int, y: Int) = {
    def auxGcd(x: Int, y: Int): Int = {
      if (0 == y)
        x
      else
        auxGcd(y, x % y)
    };
    auxGcd(intAbs(x), intAbs(y))
};

def intPow(x: Int, y: Int): Int = {
  if (y == 0)
    1
  else {
    if (isEven(y)) {
      val t = intPow(x, y/2);
      t * t
    } else {
      x * intPow(x, y - 1)
    }
  }
};

def intRead() = {
  def aux(accf: (Int, Int) => Int, acc: Int): Int = {
    val c = charRead();
    if (isCharDigit(c)) {
      aux(accf, accf(10 * acc, charDigitToInt(c)))
    } else {
      acc
    }
  };
  val c = charRead();
  if (c == '-') {
    aux((x: Int, y: Int) => x - y, 0)
  } else if (isCharDigit(c)) {
    aux((x: Int, y: Int) => x + y, charDigitToInt(c))
  } else {
    0
  }
};

def printInt(i: Int) = {
  if (i < 0) {
    printChar('-')
  };
  def aux(i: Int): Unit = {
    if (i <= -10)
      aux((i + 9) / 10);
    printChar(intCharDigit(-i % 10))
  };
  aux(if (i < 0) i else -i)
};

def pairDeriveEq[T,U](eq1: (T, T) => Boolean, eq2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => eq1(p1._1, p2._1) && eq2(p1._2, p2._2);

def pairDeriveLt[T,U](lt1: (T, T) => Boolean, lt2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => lt1(p1._1, p2._1) || (!lt1(p1._1, p2._1) && lt2(p1._2, p2._2));

def listMake1[T](e1: T) = e1::Nil;
def listMake2[T](e1: T, e2: T) = e1::listMake1[T](e2);
def listMake3[T](e1: T, e2: T, e3: T) = e1::listMake2[T](e2, e3);
def listMake4[T](e1: T, e2: T, e3: T, e4: T) = e1::listMake3[T](e2, e3, e4);
def listMake5[T](e1: T, e2: T, e3: T, e4: T, e5: T) = e1::listMake4[T](e2, e3, e4, e5);
def listMake6[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T) = e1::listMake5[T](e2, e3, e4, e5, e6);
def listMake7[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T) = e1::listMake6[T](e2, e3, e4, e5, e6, e7);
def listMake8[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T, e8: T) = e1::listMake7[T](e2, e3, e4, e5, e6, e7, e8);

def listTabulate[T](n: Int, f: Int => T) = {
  def aux(i: Int, l: List[T]): List[T] = {
    if (i == 0)
      l
    else
      aux(i - 1, f(i - 1)::l)
  };
  aux(n, Nil)
};

def listLength[T](l: List[T]): Int =
  if (l.isEmpty)
    0
  else
    1 + listLength[T](l.tail);

def listForeach[T](f: T => Unit, l: List[T]): Unit =
  if (!l.isEmpty) {
    f(l.head);
    listForeach[T](f, l.tail)
  };

def listMap[T,U](f: T => U, l: List[T]): List[U] =
  if (l.isEmpty)
    Nil
  else
    f(l.head)::listMap[T,U](f, l.tail);

def listFoldLeft[T,U](f: (T, U) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    listFoldLeft[T,U](f, f(z, l.head), l.tail);

def listFoldRight[T,U](f: (U, T) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    f(l.head, listFoldRight[T,U](f, z, l.tail));

def listEvery[T](p: T => Boolean, l: List[T]): Boolean =
  l.isEmpty || p(l.head) && listEvery[T](p, l.tail);

def listAny[T](p: T => Boolean, l: List[T]): Boolean =
  !l.isEmpty && (p(l.head) || listAny[T](p, l.tail));

def listFilter[T](p: T => Boolean, l: List[T]): List[T] =
  listFoldRight[List[T],T]((e: T, r: List[T]) =>  if (p(e)) e::r else r, Nil, l);

def listPartition[T](p: T => Boolean, l: List[T]) =
  listFoldRight[(List[T], List[T]),T](
    (e: T,  yn: (List[T], List[T])) =>
      if (p(e))
        (e::yn._1, yn._2)
      else
        (yn._1, e::yn._2),
      (Nil, Nil),
      l);

def listTake[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    Nil
  else
    l.head :: listTake[T](l.tail, n - 1);

def listDrop[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    l
  else
    listDrop[T](l.tail, n - 1);

def listNth[T](l: List[T], n: Int): T =
  listDrop[T](l, n).head;

def listReverse[T](l: List[T]): List[T] =
  listFoldLeft[List[T],T]((t: List[T], h: T) => h::t, Nil, l);

def listAppend[T](l1: List[T], l2: List[T]) =
  if (l1.isEmpty) l2
  else if (l2.isEmpty) l1
  else l1.head :: listAppend[T](l1.tail, l2);

def listZip[T,U](l1: List[T], l2: List[U]): List[(T, U)] =
  if (l1.isEmpty  || l2.isEmpty)
    Nil
  else
    (l1.head, l2.head) :: listZip[T,U](l1.tail, l2.tail);

def printString(s: String) = {
  var idx = 0;
  while (idx < s.length) {
    printChar(s(idx));
    idx = idx + 1
  };
  ()
};

def stringConcat(s1: String, s2: String) = {
  val s3 = new Array[Char](s1.length + s2.length);
  var idx = 0;
  while (idx < s1.length) {
    s3(idx) = s1(idx);
    idx = idx + 1
  };
  idx = 0;
  while (idx < s2.length) {
    s3(s1.length + idx) = s2(idx);
    idx = idx + 1
  };
  s3
};

// A PCG random number generator. (Specifically, this is the variant
// called XSH RR in the paper, with a 16-bit state and 8-bit output).
// See http://www.pcg-random.org/

def makeRNG(seed: Int) = {
  val rng = new Array[Int](1);
  rng(0) = seed & 0xFFFF;
  rng
};

def rngGetState(rng: Array[Int]) = rng(0);

def rngSetState(rng: Array[Int], state: Int) = rng(0) = state & 0xFFFF;

def rngRotateRight8(x: Int, y: Int) =
  ((x >> y) | (x << (8 - y))) & 0xFF;

def rngStep(rng: Array[Int]) =
  rngSetState(rng, rngGetState(rng) * 12829 + 47989);

def rngOutput(rng: Array[Int]) = {
  val state = rngGetState(rng);
  rngRotateRight8(0xFF & ((state ^ (state >> 5)) >> 5), state >> 13)
};

// Return the next 8-bit unsigned integer (0 to 255, included)
def rngNextInt8(rng: Array[Int]) = {
  val i = rngOutput(rng);
  rngStep(rng);
  i
};

// FIXME: this is hackish, find a better way to do it (probably using
// multiple streams, see sample/pcg32x2-demo.c in the PCG source).
def rngNextInt(rng: Array[Int]) = {
  val b0 = rngNextInt8(rng);
  val b1 = rngNextInt8(rng);
  val b2 = rngNextInt8(rng);
  val b3 = rngNextInt8(rng);
  (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
};

def arrayTabulate[T](n: Int, f: Int => T) = {
  val v = new Array[T](n);
  var i = 0;
  while (i < n) {
    v(i) = f(i);
    i = i + 1
  };
  v
};

def arraySwap[T](v: Array[T], i1: Int, i2: Int) = {
  val t = v(i1);
  v(i1) = v(i2);
  v(i2) = t
};

def arrayShuffle[T](v: Array[T], seed: Int) = {
  val rng = makeRNG(seed);
  val l = v.length;
  var i = 0;
  while (i < l) {
    val j = i + rngNextInt(rng) % (l - i);
    arraySwap[T](v, i, j);
    i = i + 1
  };
  ()
};

def auxArrayPartition[T](v: Array[T], p: T => Boolean, l: Int, h: Int) = {
  def loop(l: Int, h: Int): Int = {
    if (l >= h)
      l
    else if (p(v(l)))
      loop(l + 1, h)
    else if (!p(v(h-1)))
      loop(l, h - 1)
    else {
      arraySwap[T](v, l, h - 1);
      loop(l + 1, h + 1)
    }
  };
  loop(l, h)
};

// Reorganize the elements of the vector so that all those not
// satisfying the predicate [p] are before those that satisfy it.
// Return the index of the first element not satisfying [p], or the
// length of the vector if all elements satisfy [p].
def arrayPartition[T](v: Array[T], p: T => Boolean) =
  auxArrayPartition[T](v, p, 0, v.length);

def arrayFoldLeft[T,U](f: (T,U) => T, z: T, v: Array[U]) = {
  var i = 0;
  val l = v.length;
  var zz = z;
  while (i < l) {
    zz = f(zz, v(i));
    i = i + 1
  };
  zz
};

def arrayForeach[T](f: T => Unit, v: Array[T]) = {
  var i = 0;
  val l = v.length;
  while (i < l) {
    f(v(i));
    i = i + 1
  };
  ()
};

def arraySort[T](v: Array[T], el: (T, T) => Boolean) = {
  def qsort(l: Int, h: Int) = {
    if (h - l > 0) {
       val p = v(h);
       val pred = (x: T) => el(x, p);
       val m = auxArrayPartition[T](v, pred, l, h);
       arraySwap[T](v, m, h);
       qsort(l, m - 1);
       qsort(m + 1, h)
    }
  };
  qsort(0, v.length - 1)
};

def arrayBinarySearch[T](v: Array[T], e: T, el: (T, T) => Boolean) = {
  def loop(l: Int, h: Int): Int = {
    if (l > h)
      -1 -[error] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists9 failed: key not found: listMake5
 l
    else {
      val m = l + (h - l) / 2;
      val me = v(m);
      if (el(e, me))
        loop(l, m - 1)
      else if (el(me, e))
        loop(m + 1, h)
      else
        m
    }
  };
  loop(0, v.length - 1)
};

def arrayToList[T](v: Array[T]) = {
  def loop(i: Int): List[T] = {
    if (i == -1)
      Nil
    else
      v(i)::loop(i - 1)
  };
  loop(v.length - 1)
};

def listToArray[T](l: List[T]) = {
  val n = listLength[T](l);
  val v = new Array[T](n);
  def loop(i: Int, l: List[T]) = {
    if (i < n) {
      v(i) = l.head;
      loop(i + 1, l.tail)
    }
  };
  loop(0, l);
  v
};

[error]     at scala.collection.MapLike$class.default(MapLike.scala:228)
[error]     at scala.collection.AbstractMap.default(Map.scala:59)
[error]     at scala.collection.MapLike$class.apply(MapLike.scala:141)
[error]     at scala.collection.AbstractMap.apply(Map.scala:59)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.foreach(List.scala:381)
[error]     at scala.collection.TraversableLike$class.map(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.map(List.scala:285)
[error]     at miniscala.CPSInterpreter.eval(CPSInterpreter.scala:40)
[error]     at miniscala.CPSInterpreter.apply(CPSInterpreter.scala:18)
[error]     at miniscala.CPSInterpreterLow.apply(CPSInterpreter.scala:176)
[error]     at scala.Function1$$anonfun$andThen$1.apply(Function1.scala:52)
[error]     at miniscala.test.infrastructure.CompilerTest$class.miniscala$test$infrastructure$CompilerTest$$compileInner(CompilerTest.scala:37)
[error]     at miniscala.test.infrastructure.CompilerTest$$anonfun$compileUsingPipelineAndRedirect$1.apply(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.SandboxedTest$$anon$1.run(SandboxedTest.scala:24)
[error]     at java.security.AccessController.doPrivileged(Native Method)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTest(SandboxedTest.scala:34)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTestWithRedirectedIO(SandboxedTest.scala:45)
[error]     at miniscala.test.infrastructure.CompilerTest$class.compileUsingPipelineAndRedirect(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.CPSTest.compileUsingPipelineAndRedirect(CPSTest.scala:11)
[error]     at miniscala.test.infrastructure.CPSOptTest.testCPSLowProgramOutput(CPSOptTest.scala:91)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$class.testLibLists9(LibraryOKTests.scala:99)
[error]     at miniscala.test.CPSOptimizer_Blackbox.testLibLists9(CPSOptimizer_Blackbox.scala:7)
[error]     ...
[info] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists10 started
def printChar(c: Char) = putchar(c.toInt);

def charRead() = getchar().toChar;

def println() = printChar('\n');

val int0 = '0'.toInt;
val int9 = '9'.toInt;
def isCharDigit(c: Char) = {
  val intC = c.toInt;
  int0 <= intC && intC <= int9
};

def charDigitToInt(c: Char) = c.toInt - int0;

def intCharDigit(i: Int) = (i + int0).toChar;

def functionCompose[T,U,V](f: U => V, g: T => U) = (x: T) => f(g(x));

// Integers

def isEven(i: Int) = 0 == (1 & i);

def isOdd(i: Int) = !isEven(i);

def intAbs(i: Int) = if (i < 0) -i else i;

def intSignum(i: Int) = if (i < 0) -1 else { if (i == 0) 0 else 1 };

def intGcd(x: Int, y: Int) = {
    def auxGcd(x: Int, y: Int): Int = {
      if (0 == y)
        x
      else
        auxGcd(y, x % y)
    };
    auxGcd(intAbs(x), intAbs(y))
};

def intPow(x: Int, y: Int): Int = {
  if (y == 0)
    1
  else {
    if (isEven(y)) {
      val t = intPow(x, y/2);
      t * t
    } else {
      x * intPow(x, y - 1)
    }
  }
};

def intRead() = {
  def aux(accf: (Int, Int) => Int, acc: Int): Int = {
    val c = charRead();
    if (isCharDigit(c)) {
      aux(accf, accf(10 * acc, charDigitToInt(c)))
    } else {
      acc
    }
  };
  val c = charRead();
  if (c == '-') {
    aux((x: Int, y: Int) => x - y, 0)
  } else if (isCharDigit(c)) {
    aux((x: Int, y: Int) => x + y, charDigitToInt(c))
  } else {
    0
  }
};

def printInt(i: Int) = {
  if (i < 0) {
    printChar('-')
  };
  def aux(i: Int): Unit = {
    if (i <= -10)
      aux((i + 9) / 10);
    printChar(intCharDigit(-i % 10))
  };
  aux(if (i < 0) i else -i)
};

def pairDeriveEq[T,U](eq1: (T, T) => Boolean, eq2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => eq1(p1._1, p2._1) && eq2(p1._2, p2._2);

def pairDeriveLt[T,U](lt1: (T, T) => Boolean, lt2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => lt1(p1._1, p2._1) || (!lt1(p1._1, p2._1) && lt2(p1._2, p2._2));

def listMake1[T](e1: T) = e1::Nil;
def listMake2[T](e1: T, e2: T) = e1::listMake1[T](e2);
def listMake3[T](e1: T, e2: T, e3: T) = e1::listMake2[T](e2, e3);
def listMake4[T](e1: T, e2: T, e3: T, e4: T) = e1::listMake3[T](e2, e3, e4);
def listMake5[T](e1: T, e2: T, e3: T, e4: T, e5: T) = e1::listMake4[T](e2, e3, e4, e5);
def listMake6[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T) = e1::listMake5[T](e2, e3, e4, e5, e6);
def listMake7[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T) = e1::listMake6[T](e2, e3, e4, e5, e6, e7);
def listMake8[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T, e8: T) = e1::listMake7[T](e2, e3, e4, e5, e6, e7, e8);

def listTabulate[T](n: Int, f: Int => T) = {
  def aux(i: Int, l: List[T]): List[T] = {
    if (i == 0)
      l
    else
      aux(i - 1, f(i - 1)::l)
  };
  aux(n, Nil)
};

def listLength[T](l: List[T]): Int =
  if (l.isEmpty)
    0
  else
    1 + listLength[T](l.tail);

def listForeach[T](f: T => Unit, l: List[T]): Unit =
  if (!l.isEmpty) {
    f(l.head);
    listForeach[T](f, l.tail)
  };

def listMap[T,U](f: T => U, l: List[T]): List[U] =
  if (l.isEmpty)
    Nil
  else
    f(l.head)::listMap[T,U](f, l.tail);

def listFoldLeft[T,U](f: (T, U) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    listFoldLeft[T,U](f, f(z, l.head), l.tail);

def listFoldRight[T,U](f: (U, T) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    f(l.head, listFoldRight[T,U](f, z, l.tail));

def listEvery[T](p: T => Boolean, l: List[T]): Boolean =
  l.isEmpty || p(l.head) && listEvery[T](p, l.tail);

def listAny[T](p: T => Boolean, l: List[T]): Boolean =
  !l.isEmpty && (p(l.head) || listAny[T](p, l.tail));

def listFilter[T](p: T => Boolean, l: List[T]): List[T] =
  listFoldRight[List[T],T]((e: T, r: List[T]) =>  if (p(e)) e::r else r, Nil, l);

def listPartition[T](p: T => Boolean, l: List[T]) =
  listFoldRight[(List[T], List[T]),T](
    (e: T,  yn: (List[T], List[T])) =>
      if (p(e))
        (e::yn._1, yn._2)
      else
        (yn._1, e::yn._2),
      (Nil, Nil),
      l);

def listTake[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    Nil
  else
    l.head :: listTake[T](l.tail, n - 1);

def listDrop[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    l
  else
    listDrop[T](l.tail, n - 1);

def listNth[T](l: List[T], n: Int): T =
  listDrop[T](l, n).head;

def listReverse[T](l: List[T]): List[T] =
  listFoldLeft[List[T],T]((t: List[T], h: T) => h::t, Nil, l);

def listAppend[T](l1: List[T], l2: List[T]) =
  if (l1.isEmpty) l2
  else if (l2.isEmpty) l1
  else l1.head :: listAppend[T](l1.tail, l2);

def listZip[T,U](l1: List[T], l2: List[U]): List[(T, U)] =
  if (l1.isEmpty  || l2.isEmpty)
    Nil
  else
    (l1.head, l2.head) :: listZip[T,U](l1.tail, l2.tail);

def printString(s: String) = {
  var idx = 0;
  while (idx < s.length) {
    printChar(s(idx));
    idx = idx + 1
  };
  ()
};

def stringConcat(s1: String, s2: String) = {
  val s3 = new Array[Char](s1.length + s2.length);
  var idx = 0;
  while (idx < s1.length) {
    s3(idx) = s1(idx);
    idx = idx + 1
  };
  idx = 0;
  while (idx < s2.length) {
    s3(s1.length + idx) = s2(idx);
    idx = idx + 1
  };
  s3
};

// A PCG random number generator. (Specifically, this is the variant
// called XSH RR in the paper, with a 16-bit state and 8-bit output).
// See http://www.pcg-random.org/

def makeRNG(seed: Int) = {
  val rng = new Array[Int](1);
  rng(0) = seed & 0xFFFF;
  rng
};

def rngGetState(rng: Array[Int]) = rng(0);

def rngSetState(rng: Array[Int], state: Int) = rng(0) = state & 0xFFFF;

def rngRotateRight8(x: Int, y: Int) =
  ((x >> y) | (x << (8 - y))) & 0xFF;

def rngStep(rng: Array[Int]) =
  rngSetState(rng, rngGetState(rng) * 12829 + 47989);

def rngOutput(rng: Array[Int]) = {
  val state = rngGetState(rng);
  rngRotateRight8(0xFF & ((state ^ (state >> 5)) >> 5), state >> 13)
};

// Return the next 8-bit unsigned integer (0 to 255, included)
def rngNextInt8(rng: Array[Int]) = {
  val i = rngOutput(rng);
  rngStep(rng);
  i
};

// FIXME: this is hackish, find a better way to do it (probably using
// multiple streams, see sample/pcg32x2-demo.c in the PCG source).
def rngNextInt(rng: Array[Int]) = {
  val b0 = rngNextInt8(rng);
  val b1 = rngNextInt8(rng);
  val b2 = rngNextInt8(rng);
  val b3 = rngNextInt8(rng);
  (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
};

def arrayTabulate[T](n: Int, f: Int => T) = {
  val v = new Array[T](n);
  var i = 0;
  while (i < n) {
    v(i) = f(i);
    i = i + 1
  };
  v
};

def arraySwap[T](v: Array[T], i1: Int, i2: Int) = {
  val t = v(i1);
  v(i1) = v(i2);
  v(i2) = t
};

def arrayShuffle[T](v: Array[T], seed: Int) = {
  val rng = makeRNG(seed);
  val l = v.length;
  var i = 0;
  while (i < l) {
    val j = i + rngNextInt(rng) % (l - i);
    arraySwap[T](v, i, j);
    i = i + 1
  };
  ()
};

def auxArrayPartition[T](v: Array[T], p: T => Boolean, l: Int, h: Int) = {
  def loop(l: Int, h: Int): Int = {
    if (l >= h)
      l
    else if (p(v(l)))
      loop(l + 1, h)
    else if (!p(v(h-1)))
      loop(l, h - 1)
    else {
      arraySwap[T](v, l, h - 1);
      loop(l + 1, h + 1)
    }
  };
  loop(l, h)
};

// Reorganize the elements of the vector so that all those not
// satisfying the predicate [p] are before those that satisfy it.
// Return the index of the first element not satisfying [p], or the
// length of the vector if all elements satisfy [p].
def arrayPartition[T](v: Array[T], p: T => Boolean) =
  auxArrayPartition[T](v, p, 0, v.length);

def arrayFoldLeft[T,U](f: (T,U) => T, z: T, v: Array[U]) = {
  var i = 0;
  val l = v.length;
  var zz = z;
  while (i < l) {
    zz = f(zz, v(i));
    i = i + 1
  };
  zz
};

def arrayForeach[T](f: T => Unit, v: Array[T]) = {
  var i = 0;
  val l = v.length;
  while (i < l) {
    f(v(i));
    i = i + 1
  };
  ()
};

def arraySort[T](v: Array[T], el: (T, T) => Boolean) = {
  def qsort(l: Int, h: Int) = {
    if (h - l > 0) {
       val p = v(h);
       val pred = (x: T) => el(x, p);
       val m = auxArrayPartition[T](v, pred, l, h);
       arraySwap[T](v, m, h);
       qsort(l, m - 1);
       qsort(m + 1, h)
    }
  };
  qsort(0, v.length - 1)
};

def arrayBinarySearch[T](v: Array[T], e: T, el: (T, T) => Boolean) = {
  def loop(l: Int, h: Int): Int = {
    if (l > h)
      -1 -[error] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists10 failed: key not found: listMake5
 l
    else {
      val m = l + (h - l) / 2;
      val me = v(m);
      if (el(e, me))
        loop(l, m - 1)
      else if (el(me, e))
        loop(m + 1, h)
      else
        m
    }
  };
  loop(0, v.length - 1)
};

def arrayToList[T](v: Array[T]) = {
  def loop(i: Int): List[T] = {
    if (i == -1)
      Nil
    else
      v(i)::loop(i - 1)
  };
  loop(v.length - 1)
};

def listToArray[T](l: List[T]) = {
  val n = listLength[T](l);
  val v = new Array[T](n);
  def loop(i: Int, l: List[T]) = {
    if (i < n) {
      v(i) = l.head;
      loop(i + 1, l.tail)
    }
  };
  loop(0, l);
  v
};

[error]     at scala.collection.MapLike$class.default(MapLike.scala:228)
[error]     at scala.collection.AbstractMap.default(Map.scala:59)
[error]     at scala.collection.MapLike$class.apply(MapLike.scala:141)
[error]     at scala.collection.AbstractMap.apply(Map.scala:59)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.foreach(List.scala:381)
[error]     at scala.collection.TraversableLike$class.map(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.map(List.scala:285)
[error]     at miniscala.CPSInterpreter.eval(CPSInterpreter.scala:40)
[error]     at miniscala.CPSInterpreter.apply(CPSInterpreter.scala:18)
[error]     at miniscala.CPSInterpreterLow.apply(CPSInterpreter.scala:176)
[error]     at scala.Function1$$anonfun$andThen$1.apply(Function1.scala:52)
[error]     at miniscala.test.infrastructure.CompilerTest$class.miniscala$test$infrastructure$CompilerTest$$compileInner(CompilerTest.scala:37)
[error]     at miniscala.test.infrastructure.CompilerTest$$anonfun$compileUsingPipelineAndRedirect$1.apply(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.SandboxedTest$$anon$1.run(SandboxedTest.scala:24)
[error]     at java.security.AccessController.doPrivileged(Native Method)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTest(SandboxedTest.scala:34)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTestWithRedirectedIO(SandboxedTest.scala:45)
[error]     at miniscala.test.infrastructure.CompilerTest$class.compileUsingPipelineAndRedirect(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.CPSTest.compileUsingPipelineAndRedirect(CPSTest.scala:11)
[error]     at miniscala.test.infrastructure.CPSOptTest.testCPSLowProgramOutput(CPSOptTest.scala:91)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$class.testLibLists10(LibraryOKTests.scala:105)
[error]     at miniscala.test.CPSOptimizer_Blackbox.testLibLists10(CPSOptimizer_Blackbox.scala:7)
[error]     ...
[info] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists11 started
def printChar(c: Char) = putchar(c.toInt);

def charRead() = getchar().toChar;

def println() = printChar('\n');

val int0 = '0'.toInt;
val int9 = '9'.toInt;
def isCharDigit(c: Char) = {
  val intC = c.toInt;
  int0 <= intC && intC <= int9
};

def charDigitToInt(c: Char) = c.toInt - int0;

def intCharDigit(i: Int) = (i + int0).toChar;

def functionCompose[T,U,V](f: U => V, g: T => U) = (x: T) => f(g(x));

// Integers

def isEven(i: Int) = 0 == (1 & i);

def isOdd(i: Int) = !isEven(i);

def intAbs(i: Int) = if (i < 0) -i else i;

def intSignum(i: Int) = if (i < 0) -1 else { if (i == 0) 0 else 1 };

def intGcd(x: Int, y: Int) = {
    def auxGcd(x: Int, y: Int): Int = {
      if (0 == y)
        x
      else
        auxGcd(y, x % y)
    };
    auxGcd(intAbs(x), intAbs(y))
};

def intPow(x: Int, y: Int): Int = {
  if (y == 0)
    1
  else {
    if (isEven(y)) {
      val t = intPow(x, y/2);
      t * t
    } else {
      x * intPow(x, y - 1)
    }
  }
};

def intRead() = {
  def aux(accf: (Int, Int) => Int, acc: Int): Int = {
    val c = charRead();
    if (isCharDigit(c)) {
      aux(accf, accf(10 * acc, charDigitToInt(c)))
    } else {
      acc
    }
  };
  val c = charRead();
  if (c == '-') {
    aux((x: Int, y: Int) => x - y, 0)
  } else if (isCharDigit(c)) {
    aux((x: Int, y: Int) => x + y, charDigitToInt(c))
  } else {
    0
  }
};

def printInt(i: Int) = {
  if (i < 0) {
    printChar('-')
  };
  def aux(i: Int): Unit = {
    if (i <= -10)
      aux((i + 9) / 10);
    printChar(intCharDigit(-i % 10))
  };
  aux(if (i < 0) i else -i)
};

def pairDeriveEq[T,U](eq1: (T, T) => Boolean, eq2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => eq1(p1._1, p2._1) && eq2(p1._2, p2._2);

def pairDeriveLt[T,U](lt1: (T, T) => Boolean, lt2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => lt1(p1._1, p2._1) || (!lt1(p1._1, p2._1) && lt2(p1._2, p2._2));

def listMake1[T](e1: T) = e1::Nil;
def listMake2[T](e1: T, e2: T) = e1::listMake1[T](e2);
def listMake3[T](e1: T, e2: T, e3: T) = e1::listMake2[T](e2, e3);
def listMake4[T](e1: T, e2: T, e3: T, e4: T) = e1::listMake3[T](e2, e3, e4);
def listMake5[T](e1: T, e2: T, e3: T, e4: T, e5: T) = e1::listMake4[T](e2, e3, e4, e5);
def listMake6[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T) = e1::listMake5[T](e2, e3, e4, e5, e6);
def listMake7[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T) = e1::listMake6[T](e2, e3, e4, e5, e6, e7);
def listMake8[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T, e8: T) = e1::listMake7[T](e2, e3, e4, e5, e6, e7, e8);

def listTabulate[T](n: Int, f: Int => T) = {
  def aux(i: Int, l: List[T]): List[T] = {
    if (i == 0)
      l
    else
      aux(i - 1, f(i - 1)::l)
  };
  aux(n, Nil)
};

def listLength[T](l: List[T]): Int =
  if (l.isEmpty)
    0
  else
    1 + listLength[T](l.tail);

def listForeach[T](f: T => Unit, l: List[T]): Unit =
  if (!l.isEmpty) {
    f(l.head);
    listForeach[T](f, l.tail)
  };

def listMap[T,U](f: T => U, l: List[T]): List[U] =
  if (l.isEmpty)
    Nil
  else
    f(l.head)::listMap[T,U](f, l.tail);

def listFoldLeft[T,U](f: (T, U) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    listFoldLeft[T,U](f, f(z, l.head), l.tail);

def listFoldRight[T,U](f: (U, T) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    f(l.head, listFoldRight[T,U](f, z, l.tail));

def listEvery[T](p: T => Boolean, l: List[T]): Boolean =
  l.isEmpty || p(l.head) && listEvery[T](p, l.tail);

def listAny[T](p: T => Boolean, l: List[T]): Boolean =
  !l.isEmpty && (p(l.head) || listAny[T](p, l.tail));

def listFilter[T](p: T => Boolean, l: List[T]): List[T] =
  listFoldRight[List[T],T]((e: T, r: List[T]) =>  if (p(e)) e::r else r, Nil, l);

def listPartition[T](p: T => Boolean, l: List[T]) =
  listFoldRight[(List[T], List[T]),T](
    (e: T,  yn: (List[T], List[T])) =>
      if (p(e))
        (e::yn._1, yn._2)
      else
        (yn._1, e::yn._2),
      (Nil, Nil),
      l);

def listTake[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    Nil
  else
    l.head :: listTake[T](l.tail, n - 1);

def listDrop[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    l
  else
    listDrop[T](l.tail, n - 1);

def listNth[T](l: List[T], n: Int): T =
  listDrop[T](l, n).head;

def listReverse[T](l: List[T]): List[T] =
  listFoldLeft[List[T],T]((t: List[T], h: T) => h::t, Nil, l);

def listAppend[T](l1: List[T], l2: List[T]) =
  if (l1.isEmpty) l2
  else if (l2.isEmpty) l1
  else l1.head :: listAppend[T](l1.tail, l2);

def listZip[T,U](l1: List[T], l2: List[U]): List[(T, U)] =
  if (l1.isEmpty  || l2.isEmpty)
    Nil
  else
    (l1.head, l2.head) :: listZip[T,U](l1.tail, l2.tail);

def printString(s: String) = {
  var idx = 0;
  while (idx < s.length) {
    printChar(s(idx));
    idx = idx + 1
  };
  ()
};

def stringConcat(s1: String, s2: String) = {
  val s3 = new Array[Char](s1.length + s2.length);
  var idx = 0;
  while (idx < s1.length) {
    s3(idx) = s1(idx);
    idx = idx + 1
  };
  idx = 0;
  while (idx < s2.length) {
    s3(s1.length + idx) = s2(idx);
    idx = idx + 1
  };
  s3
};

// A PCG random number generator. (Specifically, this is the variant
// called XSH RR in the paper, with a 16-bit state and 8-bit output).
// See http://www.pcg-random.org/

def makeRNG(seed: Int) = {
  val rng = new Array[Int](1);
  rng(0) = seed & 0xFFFF;
  rng
};

def rngGetState(rng: Array[Int]) = rng(0);

def rngSetState(rng: Array[Int], state: Int) = rng(0) = state & 0xFFFF;

def rngRotateRight8(x: Int, y: Int) =
  ((x >> y) | (x << (8 - y))) & 0xFF;

def rngStep(rng: Array[Int]) =
  rngSetState(rng, rngGetState(rng) * 12829 + 47989);

def rngOutput(rng: Array[Int]) = {
  val state = rngGetState(rng);
  rngRotateRight8(0xFF & ((state ^ (state >> 5)) >> 5), state >> 13)
};

// Return the next 8-bit unsigned integer (0 to 255, included)
def rngNextInt8(rng: Array[Int]) = {
  val i = rngOutput(rng);
  rngStep(rng);
  i
};

// FIXME: this is hackish, find a better way to do it (probably using
// multiple streams, see sample/pcg32x2-demo.c in the PCG source).
def rngNextInt(rng: Array[Int]) = {
  val b0 = rngNextInt8(rng);
  val b1 = rngNextInt8(rng);
  val b2 = rngNextInt8(rng);
  val b3 = rngNextInt8(rng);
  (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
};

def arrayTabulate[T](n: Int, f: Int => T) = {
  val v = new Array[T](n);
  var i = 0;
  while (i < n) {
    v(i) = f(i);
    i = i + 1
  };
  v
};

def arraySwap[T](v: Array[T], i1: Int, i2: Int) = {
  val t = v(i1);
  v(i1) = v(i2);
  v(i2) = t
};

def arrayShuffle[T](v: Array[T], seed: Int) = {
  val rng = makeRNG(seed);
  val l = v.length;
  var i = 0;
  while (i < l) {
    val j = i + rngNextInt(rng) % (l - i);
    arraySwap[T](v, i, j);
    i = i + 1
  };
  ()
};

def auxArrayPartition[T](v: Array[T], p: T => Boolean, l: Int, h: Int) = {
  def loop(l: Int, h: Int): Int = {
    if (l >= h)
      l
    else if (p(v(l)))
      loop(l + 1, h)
    else if (!p(v(h-1)))
      loop(l, h - 1)
    else {
      arraySwap[T](v, l, h - 1);
      loop(l + 1, h + 1)
    }
  };
  loop(l, h)
};

// Reorganize the elements of the vector so that all those not
// satisfying the predicate [p] are before those that satisfy it.
// Return the index of the first element not satisfying [p], or the
// length of the vector if all elements satisfy [p].
def arrayPartition[T](v: Array[T], p: T => Boolean) =
  auxArrayPartition[T](v, p, 0, v.length);

def arrayFoldLeft[T,U](f: (T,U) => T, z: T, v: Array[U]) = {
  var i = 0;
  val l = v.length;
  var zz = z;
  while (i < l) {
    zz = f(zz, v(i));
    i = i + 1
  };
  zz
};

def arrayForeach[T](f: T => Unit, v: Array[T]) = {
  var i = 0;
  val l = v.length;
  while (i < l) {
    f(v(i));
    i = i + 1
  };
  ()
};

def arraySort[T](v: Array[T], el: (T, T) => Boolean) = {
  def qsort(l: Int, h: Int) = {
    if (h - l > 0) {
       val p = v(h);
       val pred = (x: T) => el(x, p);
       val m = auxArrayPartition[T](v, pred, l, h);
       arraySwap[T](v, m, h);
       qsort(l, m - 1);
       qsort(m + 1, h)
    }
  };
  qsort(0, v.length - 1)
};

def arrayBinarySearch[T](v: Array[T], e: T, el: (T, T) => Boolean) = {
  def loop(l: Int, h: Int): Int = {
    if (l > h)
      -1 -[error] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists11 failed: key not found: listMake4
 l
    else {
      val m = l + (h - l) / 2;
      val me = v(m);
      if (el(e, me))
        loop(l, m - 1)
      else if (el(me, e))
        loop(m + 1, h)
      else
        m
    }
  };
  loop(0, v.length - 1)
};

def arrayToList[T](v: Array[T]) = {
  def loop(i: Int): List[T] = {
    if (i == -1)
      Nil
    else
      v(i)::loop(i - 1)
  };
  loop(v.length - 1)
};

def listToArray[T](l: List[T]) = {
  val n = listLength[T](l);
  val v = new Array[T](n);
  def loop(i: Int, l: List[T]) = {
    if (i < n) {
      v(i) = l.head;
      loop(i + 1, l.tail)
    }
  };
  loop(0, l);
  v
};

[error]     at scala.collection.MapLike$class.default(MapLike.scala:228)
[error]     at scala.collection.AbstractMap.default(Map.scala:59)
[error]     at scala.collection.MapLike$class.apply(MapLike.scala:141)
[error]     at scala.collection.AbstractMap.apply(Map.scala:59)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.foreach(List.scala:381)
[error]     at scala.collection.TraversableLike$class.map(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.map(List.scala:285)
[error]     at miniscala.CPSInterpreter.eval(CPSInterpreter.scala:40)
[error]     at miniscala.CPSInterpreter.apply(CPSInterpreter.scala:18)
[error]     at miniscala.CPSInterpreterLow.apply(CPSInterpreter.scala:176)
[error]     at scala.Function1$$anonfun$andThen$1.apply(Function1.scala:52)
[error]     at miniscala.test.infrastructure.CompilerTest$class.miniscala$test$infrastructure$CompilerTest$$compileInner(CompilerTest.scala:37)
[error]     at miniscala.test.infrastructure.CompilerTest$$anonfun$compileUsingPipelineAndRedirect$1.apply(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.SandboxedTest$$anon$1.run(SandboxedTest.scala:24)
[error]     at java.security.AccessController.doPrivileged(Native Method)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTest(SandboxedTest.scala:34)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTestWithRedirectedIO(SandboxedTest.scala:45)
[error]     at miniscala.test.infrastructure.CompilerTest$class.compileUsingPipelineAndRedirect(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.CPSTest.compileUsingPipelineAndRedirect(CPSTest.scala:11)
[error]     at miniscala.test.infrastructure.CPSOptTest.testCPSLowProgramOutput(CPSOptTest.scala:91)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$class.testLibLists11(LibraryOKTests.scala:111)
[error]     at miniscala.test.CPSOptimizer_Blackbox.testLibLists11(CPSOptimizer_Blackbox.scala:7)
[error]     ...
[info] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists13 started
def printChar(c: Char) = putchar(c.toInt);

def charRead() = getchar().toChar;

def println() = printChar('\n');

val int0 = '0'.toInt;
val int9 = '9'.toInt;
def isCharDigit(c: Char) = {
  val intC = c.toInt;
  int0 <= intC && intC <= int9
};

def charDigitToInt(c: Char) = c.toInt - int0;

def intCharDigit(i: Int) = (i + int0).toChar;

def functionCompose[T,U,V](f: U => V, g: T => U) = (x: T) => f(g(x));

// Integers

def isEven(i: Int) = 0 == (1 & i);

def isOdd(i: Int) = !isEven(i);

def intAbs(i: Int) = if (i < 0) -i else i;

def intSignum(i: Int) = if (i < 0) -1 else { if (i == 0) 0 else 1 };

def intGcd(x: Int, y: Int) = {
    def auxGcd(x: Int, y: Int): Int = {
      if (0 == y)
        x
      else
        auxGcd(y, x % y)
    };
    auxGcd(intAbs(x), intAbs(y))
};

def intPow(x: Int, y: Int): Int = {
  if (y == 0)
    1
  else {
    if (isEven(y)) {
      val t = intPow(x, y/2);
      t * t
    } else {
      x * intPow(x, y - 1)
    }
  }
};

def intRead() = {
  def aux(accf: (Int, Int) => Int, acc: Int): Int = {
    val c = charRead();
    if (isCharDigit(c)) {
      aux(accf, accf(10 * acc, charDigitToInt(c)))
    } else {
      acc
    }
  };
  val c = charRead();
  if (c == '-') {
    aux((x: Int, y: Int) => x - y, 0)
  } else if (isCharDigit(c)) {
    aux((x: Int, y: Int) => x + y, charDigitToInt(c))
  } else {
    0
  }
};

def printInt(i: Int) = {
  if (i < 0) {
    printChar('-')
  };
  def aux(i: Int): Unit = {
    if (i <= -10)
      aux((i + 9) / 10);
    printChar(intCharDigit(-i % 10))
  };
  aux(if (i < 0) i else -i)
};

def pairDeriveEq[T,U](eq1: (T, T) => Boolean, eq2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => eq1(p1._1, p2._1) && eq2(p1._2, p2._2);

def pairDeriveLt[T,U](lt1: (T, T) => Boolean, lt2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => lt1(p1._1, p2._1) || (!lt1(p1._1, p2._1) && lt2(p1._2, p2._2));

def listMake1[T](e1: T) = e1::Nil;
def listMake2[T](e1: T, e2: T) = e1::listMake1[T](e2);
def listMake3[T](e1: T, e2: T, e3: T) = e1::listMake2[T](e2, e3);
def listMake4[T](e1: T, e2: T, e3: T, e4: T) = e1::listMake3[T](e2, e3, e4);
def listMake5[T](e1: T, e2: T, e3: T, e4: T, e5: T) = e1::listMake4[T](e2, e3, e4, e5);
def listMake6[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T) = e1::listMake5[T](e2, e3, e4, e5, e6);
def listMake7[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T) = e1::listMake6[T](e2, e3, e4, e5, e6, e7);
def listMake8[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T, e8: T) = e1::listMake7[T](e2, e3, e4, e5, e6, e7, e8);

def listTabulate[T](n: Int, f: Int => T) = {
  def aux(i: Int, l: List[T]): List[T] = {
    if (i == 0)
      l
    else
      aux(i - 1, f(i - 1)::l)
  };
  aux(n, Nil)
};

def listLength[T](l: List[T]): Int =
  if (l.isEmpty)
    0
  else
    1 + listLength[T](l.tail);

def listForeach[T](f: T => Unit, l: List[T]): Unit =
  if (!l.isEmpty) {
    f(l.head);
    listForeach[T](f, l.tail)
  };

def listMap[T,U](f: T => U, l: List[T]): List[U] =
  if (l.isEmpty)
    Nil
  else
    f(l.head)::listMap[T,U](f, l.tail);

def listFoldLeft[T,U](f: (T, U) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    listFoldLeft[T,U](f, f(z, l.head), l.tail);

def listFoldRight[T,U](f: (U, T) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    f(l.head, listFoldRight[T,U](f, z, l.tail));

def listEvery[T](p: T => Boolean, l: List[T]): Boolean =
  l.isEmpty || p(l.head) && listEvery[T](p, l.tail);

def listAny[T](p: T => Boolean, l: List[T]): Boolean =
  !l.isEmpty && (p(l.head) || listAny[T](p, l.tail));

def listFilter[T](p: T => Boolean, l: List[T]): List[T] =
  listFoldRight[List[T],T]((e: T, r: List[T]) =>  if (p(e)) e::r else r, Nil, l);

def listPartition[T](p: T => Boolean, l: List[T]) =
  listFoldRight[(List[T], List[T]),T](
    (e: T,  yn: (List[T], List[T])) =>
      if (p(e))
        (e::yn._1, yn._2)
      else
        (yn._1, e::yn._2),
      (Nil, Nil),
      l);

def listTake[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    Nil
  else
    l.head :: listTake[T](l.tail, n - 1);

def listDrop[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    l
  else
    listDrop[T](l.tail, n - 1);

def listNth[T](l: List[T], n: Int): T =
  listDrop[T](l, n).head;

def listReverse[T](l: List[T]): List[T] =
  listFoldLeft[List[T],T]((t: List[T], h: T) => h::t, Nil, l);

def listAppend[T](l1: List[T], l2: List[T]) =
  if (l1.isEmpty) l2
  else if (l2.isEmpty) l1
  else l1.head :: listAppend[T](l1.tail, l2);

def listZip[T,U](l1: List[T], l2: List[U]): List[(T, U)] =
  if (l1.isEmpty  || l2.isEmpty)
    Nil
  else
    (l1.head, l2.head) :: listZip[T,U](l1.tail, l2.tail);

def printString(s: String) = {
  var idx = 0;
  while (idx < s.length) {
    printChar(s(idx));
    idx = idx + 1
  };
  ()
};

def stringConcat(s1: String, s2: String) = {
  val s3 = new Array[Char](s1.length + s2.length);
  var idx = 0;
  while (idx < s1.length) {
    s3(idx) = s1(idx);
    idx = idx + 1
  };
  idx = 0;
  while (idx < s2.length) {
    s3(s1.length + idx) = s2(idx);
    idx = idx + 1
  };
  s3
};

// A PCG random number generator. (Specifically, this is the variant
// called XSH RR in the paper, with a 16-bit state and 8-bit output).
// See http://www.pcg-random.org/

def makeRNG(seed: Int) = {
  val rng = new Array[Int](1);
  rng(0) = seed & 0xFFFF;
  rng
};

def rngGetState(rng: Array[Int]) = rng(0);

def rngSetState(rng: Array[Int], state: Int) = rng(0) = state & 0xFFFF;

def rngRotateRight8(x: Int, y: Int) =
  ((x >> y) | (x << (8 - y))) & 0xFF;

def rngStep(rng: Array[Int]) =
  rngSetState(rng, rngGetState(rng) * 12829 + 47989);

def rngOutput(rng: Array[Int]) = {
  val state = rngGetState(rng);
  rngRotateRight8(0xFF & ((state ^ (state >> 5)) >> 5), state >> 13)
};

// Return the next 8-bit unsigned integer (0 to 255, included)
def rngNextInt8(rng: Array[Int]) = {
  val i = rngOutput(rng);
  rngStep(rng);
  i
};

// FIXME: this is hackish, find a better way to do it (probably using
// multiple streams, see sample/pcg32x2-demo.c in the PCG source).
def rngNextInt(rng: Array[Int]) = {
  val b0 = rngNextInt8(rng);
  val b1 = rngNextInt8(rng);
  val b2 = rngNextInt8(rng);
  val b3 = rngNextInt8(rng);
  (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
};

def arrayTabulate[T](n: Int, f: Int => T) = {
  val v = new Array[T](n);
  var i = 0;
  while (i < n) {
    v(i) = f(i);
    i = i + 1
  };
  v
};

def arraySwap[T](v: Array[T], i1: Int, i2: Int) = {
  val t = v(i1);
  v(i1) = v(i2);
  v(i2) = t
};

def arrayShuffle[T](v: Array[T], seed: Int) = {
  val rng = makeRNG(seed);
  val l = v.length;
  var i = 0;
  while (i < l) {
    val j = i + rngNextInt(rng) % (l - i);
    arraySwap[T](v, i, j);
    i = i + 1
  };
  ()
};

def auxArrayPartition[T](v: Array[T], p: T => Boolean, l: Int, h: Int) = {
  def loop(l: Int, h: Int): Int = {
    if (l >= h)
      l
    else if (p(v(l)))
      loop(l + 1, h)
    else if (!p(v(h-1)))
      loop(l, h - 1)
    else {
      arraySwap[T](v, l, h - 1);
      loop(l + 1, h + 1)
    }
  };
  loop(l, h)
};

// Reorganize the elements of the vector so that all those not
// satisfying the predicate [p] are before those that satisfy it.
// Return the index of the first element not satisfying [p], or the
// length of the vector if all elements satisfy [p].
def arrayPartition[T](v: Array[T], p: T => Boolean) =
  auxArrayPartition[T](v, p, 0, v.length);

def arrayFoldLeft[T,U](f: (T,U) => T, z: T, v: Array[U]) = {
  var i = 0;
  val l = v.length;
  var zz = z;
  while (i < l) {
    zz = f(zz, v(i));
    i = i + 1
  };
  zz
};

def arrayForeach[T](f: T => Unit, v: Array[T]) = {
  var i = 0;
  val l = v.length;
  while (i < l) {
    f(v(i));
    i = i + 1
  };
  ()
};

def arraySort[T](v: Array[T], el: (T, T) => Boolean) = {
  def qsort(l: Int, h: Int) = {
    if (h - l > 0) {
       val p = v(h);
       val pred = (x: T) => el(x, p);
       val m = auxArrayPartition[T](v, pred, l, h);
       arraySwap[T](v, m, h);
       qsort(l, m - 1);
       qsort(m + 1, h)
    }
  };
  qsort(0, v.length - 1)
};

def arrayBinarySearch[T](v: Array[T], e: T, el: (T, T) => Boolean) = {
  def loop(l: Int, h: Int): Int = {
    if (l > h)
      -1 -[error] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists13 failed: key not found: printChar_7
 l
    else {
      val m = l + (h - l) / 2;
      val me = v(m);
      if (el(e, me))
        loop(l, m - 1)
      else if (el(me, e))
        loop(m + 1, h)
      else
        m
    }
  };
  loop(0, v.length - 1)
};

def arrayToList[T](v: Array[T]) = {
  def loop(i: Int): List[T] = {
    if (i == -1)
      Nil
    else
      v(i)::loop(i - 1)
  };
  loop(v.length - 1)
};

def listToArray[T](l: List[T]) = {
  val n = listLength[T](l);
  val v = new Array[T](n);
  def loop(i: Int, l: List[T]) = {
    if (i < n) {
      v(i) = l.head;
      loop(i + 1, l.tail)
    }
  };
  loop(0, l);
  v
};

[error]     at scala.collection.MapLike$class.default(MapLike.scala:228)
[error]     at scala.collection.AbstractMap.default(Map.scala:59)
[error]     at scala.collection.MapLike$class.apply(MapLike.scala:141)
[error]     at scala.collection.AbstractMap.apply(Map.scala:59)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at miniscala.CPSInterpreter.eval(CPSInterpreter.scala:63)
[error]     at miniscala.CPSInterpreter.apply(CPSInterpreter.scala:18)
[error]     at miniscala.CPSInterpreterLow.apply(CPSInterpreter.scala:176)
[error]     at scala.Function1$$anonfun$andThen$1.apply(Function1.scala:52)
[error]     at miniscala.test.infrastructure.CompilerTest$class.miniscala$test$infrastructure$CompilerTest$$compileInner(CompilerTest.scala:37)
[error]     at miniscala.test.infrastructure.CompilerTest$$anonfun$compileUsingPipelineAndRedirect$1.apply(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.SandboxedTest$$anon$1.run(SandboxedTest.scala:24)
[error]     at java.security.AccessController.doPrivileged(Native Method)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTest(SandboxedTest.scala:34)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTestWithRedirectedIO(SandboxedTest.scala:45)
[error]     at miniscala.test.infrastructure.CompilerTest$class.compileUsingPipelineAndRedirect(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.CPSTest.compileUsingPipelineAndRedirect(CPSTest.scala:11)
[error]     at miniscala.test.infrastructure.CPSOptTest.testCPSLowProgramOutput(CPSOptTest.scala:91)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$class.testLibLists13(LibraryOKTests.scala:127)
[error]     at miniscala.test.CPSOptimizer_Blackbox.testLibLists13(CPSOptimizer_Blackbox.scala:7)
[error]     ...
[info] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists12 started
def printChar(c: Char) = putchar(c.toInt);

def charRead() = getchar().toChar;

def println() = printChar('\n');

val int0 = '0'.toInt;
val int9 = '9'.toInt;
def isCharDigit(c: Char) = {
  val intC = c.toInt;
  int0 <= intC && intC <= int9
};

def charDigitToInt(c: Char) = c.toInt - int0;

def intCharDigit(i: Int) = (i + int0).toChar;

def functionCompose[T,U,V](f: U => V, g: T => U) = (x: T) => f(g(x));

// Integers

def isEven(i: Int) = 0 == (1 & i);

def isOdd(i: Int) = !isEven(i);

def intAbs(i: Int) = if (i < 0) -i else i;

def intSignum(i: Int) = if (i < 0) -1 else { if (i == 0) 0 else 1 };

def intGcd(x: Int, y: Int) = {
    def auxGcd(x: Int, y: Int): Int = {
      if (0 == y)
        x
      else
        auxGcd(y, x % y)
    };
    auxGcd(intAbs(x), intAbs(y))
};

def intPow(x: Int, y: Int): Int = {
  if (y == 0)
    1
  else {
    if (isEven(y)) {
      val t = intPow(x, y/2);
      t * t
    } else {
      x * intPow(x, y - 1)
    }
  }
};

def intRead() = {
  def aux(accf: (Int, Int) => Int, acc: Int): Int = {
    val c = charRead();
    if (isCharDigit(c)) {
      aux(accf, accf(10 * acc, charDigitToInt(c)))
    } else {
      acc
    }
  };
  val c = charRead();
  if (c == '-') {
    aux((x: Int, y: Int) => x - y, 0)
  } else if (isCharDigit(c)) {
    aux((x: Int, y: Int) => x + y, charDigitToInt(c))
  } else {
    0
  }
};

def printInt(i: Int) = {
  if (i < 0) {
    printChar('-')
  };
  def aux(i: Int): Unit = {
    if (i <= -10)
      aux((i + 9) / 10);
    printChar(intCharDigit(-i % 10))
  };
  aux(if (i < 0) i else -i)
};

def pairDeriveEq[T,U](eq1: (T, T) => Boolean, eq2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => eq1(p1._1, p2._1) && eq2(p1._2, p2._2);

def pairDeriveLt[T,U](lt1: (T, T) => Boolean, lt2: (U, U) => Boolean) =
  (p1: (T, U), p2: (T, U)) => lt1(p1._1, p2._1) || (!lt1(p1._1, p2._1) && lt2(p1._2, p2._2));

def listMake1[T](e1: T) = e1::Nil;
def listMake2[T](e1: T, e2: T) = e1::listMake1[T](e2);
def listMake3[T](e1: T, e2: T, e3: T) = e1::listMake2[T](e2, e3);
def listMake4[T](e1: T, e2: T, e3: T, e4: T) = e1::listMake3[T](e2, e3, e4);
def listMake5[T](e1: T, e2: T, e3: T, e4: T, e5: T) = e1::listMake4[T](e2, e3, e4, e5);
def listMake6[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T) = e1::listMake5[T](e2, e3, e4, e5, e6);
def listMake7[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T) = e1::listMake6[T](e2, e3, e4, e5, e6, e7);
def listMake8[T](e1: T, e2: T, e3: T, e4: T, e5: T, e6: T, e7: T, e8: T) = e1::listMake7[T](e2, e3, e4, e5, e6, e7, e8);

def listTabulate[T](n: Int, f: Int => T) = {
  def aux(i: Int, l: List[T]): List[T] = {
    if (i == 0)
      l
    else
      aux(i - 1, f(i - 1)::l)
  };
  aux(n, Nil)
};

def listLength[T](l: List[T]): Int =
  if (l.isEmpty)
    0
  else
    1 + listLength[T](l.tail);

def listForeach[T](f: T => Unit, l: List[T]): Unit =
  if (!l.isEmpty) {
    f(l.head);
    listForeach[T](f, l.tail)
  };

def listMap[T,U](f: T => U, l: List[T]): List[U] =
  if (l.isEmpty)
    Nil
  else
    f(l.head)::listMap[T,U](f, l.tail);

def listFoldLeft[T,U](f: (T, U) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    listFoldLeft[T,U](f, f(z, l.head), l.tail);

def listFoldRight[T,U](f: (U, T) => T, z: T, l: List[U]): T =
  if (l.isEmpty)
    z
  else
    f(l.head, listFoldRight[T,U](f, z, l.tail));

def listEvery[T](p: T => Boolean, l: List[T]): Boolean =
  l.isEmpty || p(l.head) && listEvery[T](p, l.tail);

def listAny[T](p: T => Boolean, l: List[T]): Boolean =
  !l.isEmpty && (p(l.head) || listAny[T](p, l.tail));

def listFilter[T](p: T => Boolean, l: List[T]): List[T] =
  listFoldRight[List[T],T]((e: T, r: List[T]) =>  if (p(e)) e::r else r, Nil, l);

def listPartition[T](p: T => Boolean, l: List[T]) =
  listFoldRight[(List[T], List[T]),T](
    (e: T,  yn: (List[T], List[T])) =>
      if (p(e))
        (e::yn._1, yn._2)
      else
        (yn._1, e::yn._2),
      (Nil, Nil),
      l);

def listTake[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    Nil
  else
    l.head :: listTake[T](l.tail, n - 1);

def listDrop[T](l: List[T], n: Int): List[T] =
  if (0 == n || l.isEmpty)
    l
  else
    listDrop[T](l.tail, n - 1);

def listNth[T](l: List[T], n: Int): T =
  listDrop[T](l, n).head;

def listReverse[T](l: List[T]): List[T] =
  listFoldLeft[List[T],T]((t: List[T], h: T) => h::t, Nil, l);

def listAppend[T](l1: List[T], l2: List[T]) =
  if (l1.isEmpty) l2
  else if (l2.isEmpty) l1
  else l1.head :: listAppend[T](l1.tail, l2);

def listZip[T,U](l1: List[T], l2: List[U]): List[(T, U)] =
  if (l1.isEmpty  || l2.isEmpty)
    Nil
  else
    (l1.head, l2.head) :: listZip[T,U](l1.tail, l2.tail);

def printString(s: String) = {
  var idx = 0;
  while (idx < s.length) {
    printChar(s(idx));
    idx = idx + 1
  };
  ()
};

def stringConcat(s1: String, s2: String) = {
  val s3 = new Array[Char](s1.length + s2.length);
  var idx = 0;
  while (idx < s1.length) {
    s3(idx) = s1(idx);
    idx = idx + 1
  };
  idx = 0;
  while (idx < s2.length) {
    s3(s1.length + idx) = s2(idx);
    idx = idx + 1
  };
  s3
};

// A PCG random number generator. (Specifically, this is the variant
// called XSH RR in the paper, with a 16-bit state and 8-bit output).
// See http://www.pcg-random.org/

def makeRNG(seed: Int) = {
  val rng = new Array[Int](1);
  rng(0) = seed & 0xFFFF;
  rng
};

def rngGetState(rng: Array[Int]) = rng(0);

def rngSetState(rng: Array[Int], state: Int) = rng(0) = state & 0xFFFF;

def rngRotateRight8(x: Int, y: Int) =
  ((x >> y) | (x << (8 - y))) & 0xFF;

def rngStep(rng: Array[Int]) =
  rngSetState(rng, rngGetState(rng) * 12829 + 47989);

def rngOutput(rng: Array[Int]) = {
  val state = rngGetState(rng);
  rngRotateRight8(0xFF & ((state ^ (state >> 5)) >> 5), state >> 13)
};

// Return the next 8-bit unsigned integer (0 to 255, included)
def rngNextInt8(rng: Array[Int]) = {
  val i = rngOutput(rng);
  rngStep(rng);
  i
};

// FIXME: this is hackish, find a better way to do it (probably using
// multiple streams, see sample/pcg32x2-demo.c in the PCG source).
def rngNextInt(rng: Array[Int]) = {
  val b0 = rngNextInt8(rng);
  val b1 = rngNextInt8(rng);
  val b2 = rngNextInt8(rng);
  val b3 = rngNextInt8(rng);
  (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
};

def arrayTabulate[T](n: Int, f: Int => T) = {
  val v = new Array[T](n);
  var i = 0;
  while (i < n) {
    v(i) = f(i);
    i = i + 1
  };
  v
};

def arraySwap[T](v: Array[T], i1: Int, i2: Int) = {
  val t = v(i1);
  v(i1) = v(i2);
  v(i2) = t
};

def arrayShuffle[T](v: Array[T], seed: Int) = {
  val rng = makeRNG(seed);
  val l = v.length;
  var i = 0;
  while (i < l) {
    val j = i + rngNextInt(rng) % (l - i);
    arraySwap[T](v, i, j);
    i = i + 1
  };
  ()
};

def auxArrayPartition[T](v: Array[T], p: T => Boolean, l: Int, h: Int) = {
  def loop(l: Int, h: Int): Int = {
    if (l >= h)
      l
    else if (p(v(l)))
      loop(l + 1, h)
    else if (!p(v(h-1)))
      loop(l, h - 1)
    else {
      arraySwap[T](v, l, h - 1);
      loop(l + 1, h + 1)
    }
  };
  loop(l, h)
};

// Reorganize the elements of the vector so that all those not
// satisfying the predicate [p] are before those that satisfy it.
// Return the index of the first element not satisfying [p], or the
// length of the vector if all elements satisfy [p].
def arrayPartition[T](v: Array[T], p: T => Boolean) =
  auxArrayPartition[T](v, p, 0, v.length);

def arrayFoldLeft[T,U](f: (T,U) => T, z: T, v: Array[U]) = {
  var i = 0;
  val l = v.length;
  var zz = z;
  while (i < l) {
    zz = f(zz, v(i));
    i = i + 1
  };
  zz
};

def arrayForeach[T](f: T => Unit, v: Array[T]) = {
  var i = 0;
  val l = v.length;
  while (i < l) {
    f(v(i));
    i = i + 1
  };
  ()
};

def arraySort[T](v: Array[T], el: (T, T) => Boolean) = {
  def qsort(l: Int, h: Int) = {
    if (h - l > 0) {
       val p = v(h);
       val pred = (x: T) => el(x, p);
       val m = auxArrayPartition[T](v, pred, l, h);
       arraySwap[T](v, m, h);
       qsort(l, m - 1);
       qsort(m + 1, h)
    }
  };
  qsort(0, v.length - 1)
};

def arrayBinarySearch[T](v: Array[T], e: T, el: (T, T) => Boolean) = {
  def loop(l: Int, h: Int): Int = {
    if (l > h)
      -1 -[error] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists12 failed: key not found: listMake2
 l
    else {
      val m = l + (h - l) / 2;
      val me = v(m);
      if (el(e, me))
        loop(l, m - 1)
      else if (el(me, e))
        loop(m + 1, h)
      else
        m
    }
  };
  loop(0, v.length - 1)
};

def arrayToList[T](v: Array[T]) = {
  def loop(i: Int): List[T] = {
    if (i == -1)
      Nil
    else
      v(i)::loop(i - 1)
  };
  loop(v.length - 1)
};

def listToArray[T](l: List[T]) = {
  val n = listLength[T](l);
  val v = new Array[T](n);
  def loop(i: Int, l: List[T]) = {
    if (i < n) {
      v(i) = l.head;
      loop(i + 1, l.tail)
    }
  };
  loop(0, l);
  v
};

[error]     at scala.collection.MapLike$class.default(MapLike.scala:228)
[error]     at scala.collection.AbstractMap.default(Map.scala:59)
[error]     at scala.collection.MapLike$class.apply(MapLike.scala:141)
[error]     at scala.collection.AbstractMap.apply(Map.scala:59)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.PartialFunction$class.applyOrElse(PartialFunction.scala:123)
[error]     at scala.collection.AbstractMap.applyOrElse(Map.scala:59)
[error]     at scala.PartialFunction$OrElse.apply(PartialFunction.scala:167)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.foreach(List.scala:381)
[error]     at scala.collection.TraversableLike$class.map(TraversableLike.scala:245)
[error]     at scala.collection.immutable.List.map(List.scala:285)
[error]     at miniscala.CPSInterpreter.eval(CPSInterpreter.scala:40)
[error]     at miniscala.CPSInterpreter.apply(CPSInterpreter.scala:18)
[error]     at miniscala.CPSInterpreterLow.apply(CPSInterpreter.scala:176)
[error]     at scala.Function1$$anonfun$andThen$1.apply(Function1.scala:52)
[error]     at miniscala.test.infrastructure.CompilerTest$class.miniscala$test$infrastructure$CompilerTest$$compileInner(CompilerTest.scala:37)
[error]     at miniscala.test.infrastructure.CompilerTest$$anonfun$compileUsingPipelineAndRedirect$1.apply(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.SandboxedTest$$anon$1.run(SandboxedTest.scala:24)
[error]     at java.security.AccessController.doPrivileged(Native Method)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTest(SandboxedTest.scala:34)
[error]     at miniscala.test.infrastructure.SandboxedTest.sandboxedTestWithRedirectedIO(SandboxedTest.scala:45)
[error]     at miniscala.test.infrastructure.CompilerTest$class.compileUsingPipelineAndRedirect(CompilerTest.scala:44)
[error]     at miniscala.test.infrastructure.CPSTest.compileUsingPipelineAndRedirect(CPSTest.scala:11)
[error]     at miniscala.test.infrastructure.CPSOptTest.testCPSLowProgramOutput(CPSOptTest.scala:91)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.CPSOptimizer_Blackbox$$anonfun$1.apply(CPSOptimizer_Blackbox.scala:9)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$$anonfun$compileAndInterpretWithLib$1.apply(LibraryOKTests.scala:19)
[error]     at miniscala.test.ok.LibraryOKTests$class.testLibLists12(LibraryOKTests.scala:121)
[error]     at miniscala.test.CPSOptimizer_Blackbox.testLibLists12(CPSOptimizer_Blackbox.scala:7)
[error]     ...
[info] Test miniscala.test.CPSOptimizer_Blackbox.testLibStrings1 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testLibLists1 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testLibStrings3 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testLibStrings2 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testConditional1 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testConditional2 started
[info] Test miniscala.test.CPSOptimizer_Blackbox.testConditional4 started
[info] Test run finished: 16 failed, 0 ignored, 62 total, 3.453s
[error] Failed: Total 104, Failed 26, Errors 0, Passed 78
[error] Failed tests:
[error] 	miniscala.test.CPSOptimizer_Blackbox
[error] 	miniscala.test.CPSOptimizer_Greybox
[error] (test:test) sbt.TestsFailedException: Tests unsuccessful
[error] Total time: 10 s, completed Nov 10, 2017 11:13:40 PM
